PRO cpropstoo_larson_relation_app , inprop = inprop $
					   , inner_pc = inner_pc $
					   , ring_pc = ring_pc $
             , outer_pc = outer_pc $
					   , xrange = xrange $
					   , yrange = yrange $
					   , vrmsmode = vrmsmode $
					   , inc = inc $ ; for sigma_effective
					   , shear_table = shear_table $
	                   , outfile=outfile $
                      , nofitting=nofitting $ 
                        , checkfile_re = checkfile_re $ 
                          , alpha_co = alpha_co
	                ; , intable = intable $ 

;+
; NAME: 
;   cpropstoo_larson_relation
;
; PURPOSE:
;   Perform the larson relation analysis
;  
;   
; INPUTS:
;   intable  --  the table of gmc properties generated by 'cpropsdist_gmc_table.pro'
;   inner_pc --  the distance boundary in [pc] for 'inner' and 'outer' regions
;               of galaxies
;   vrmsmode --  vrms mode: "obs", "turb", "eff"
;   shear_table -- the table including shear parameters generated by 
;                  "cpropstoo_shear_table.pro"
; 
; KEYWORD:
;    
; OUTPUTS:
;   outfile  --  the '.eps' file for output figure
; 
; HISTORY:
;   20170303  LJ   introduced

; HEAD MESSAGE
  print, '========================================='
  print, 'CPROPSTOO: GENERATE LARSON RELATION PLOT'
  print, '========================================='


array_re = fltarr(file_lines(checkfile_re))
openr, lun, checkfile_re, /get_lun
readf, lun, array_re
free_lun, lun

resolve_ind = where( array_re gt 0.5, res_ct)

print, 'alpha = ', alpha_co


; READ GMC TABLE 
  ; readcol,intable, ID, RA, Dec, Vlsr, R, d_R, vrms, d_vrms, vturb, d_vturb, $
  ;         Lum, d_Lum, Mlum, d_Mlum, Tmax, Omega_shear, Theta_shear,distance, $
  ;         F='I, a, a, f, f, f, f, f, f, f, f, f, f, f, f, f, f, f'
  ; ;resolve_ind=where((R gt 0.0) and (vrms ne 0.))
  ; resolve_ind=where(R gt 0.0)
  ; R=R[resolve_ind]
  ; d_R=d_R[resolve_ind]
  ; distance=distance[resolve_ind]
  ; Lum=Lum[resolve_ind]*1e4
  ; d_Lum=d_Lum[resolve_ind]*1e4

  if keyword_set(nofitting) then begin ; store the fitting result (#3, first run) of all clouds, since it's the slowest step
  slope_A0 = [0, 0.29012310, 0.10774052]
  zp_A0 = [0, 0.23532082, 0.14997317]

  slope_A1 = [0, 2.6004109, 0.10638780]
  zp_A1 = [0, 1.3608500,  0.15157707]

  slope_A2 = [0, 3.3160266, 0.43122989]
  zp_A2 = [0, 2.8317953, 0.27265512]
endif

  restore, inprop
  ; resolve_ind = where( props.resolve_spatial * props.resolve_spectral eq 1.0 )
  mad_to_sig = 1.0 ; 1.4826
  R = props.radrms_extrap_deconv
  R = R[resolve_ind]
  d_R = props.radrms_extrap_deconv_uc
  d_R = d_R[resolve_ind] * R * mad_to_sig  ; mad * 1.4826 = sigma
  logR=alog10(R)
  d_logR=1./alog(10.)*d_R/R
  d_logR_mad=1./alog(10.)*(d_R/mad_to_sig)/R

  distance = props.r_gal
  distance = distance[resolve_ind]

  peak = props.peaknum
  peak = peak[resolve_ind]

  Lum = props.lum_extrap
  Lum = Lum[resolve_ind]
  d_Lum=props.lum_extrap_uc
  d_Lum = d_Lum[resolve_ind] * Lum * mad_to_sig 
  logLum=alog10(Lum)
  d_logLum=1./alog(10.)*d_Lum/Lum
  d_logLum_mad=1./alog(10.)*(d_Lum/mad_to_sig)/Lum

  ; different vrms mode
  if n_elements(vrmsmode) eq 0 then begin
    vrmsmode = "obs"
    vrms = props.vrms_extrap_deconv
    vrms = vrms[resolve_ind]
    d_vrms = props.vrms_extrap_deconv_uc
    d_vrms = d_vrms[resolve_ind] * vrms * mad_to_sig 
    ; vrms=vrms[resolve_ind]
    ; d_vrms=d_vrms[resolve_ind]
  endif else begin
    if vrmsmode eq "turb"  then begin
  	vrms=vturb[resolve_ind]
  	d_vrms=d_vturb[resolve_ind]
    endif 
    if vrmsmode eq "eff"  then begin
	  vrms_obs = vrms[resolve_ind]
	  vrms_shift = vturb[resolve_ind]
	  dvrms_obs = d_vrms[resolve_ind]
	  dvrms_shift = d_vturb[resolve_ind]

	  readcol, shear_table, ID, Omega, T, vrms_eff, dvrms_eff, $
          vrms_pred, vir_eff, OmegaStd, Tstd, F='I,f,f,f,f,f,f,f,f'
      vrms=vrms_eff[resolve_ind]

	  if n_elements(inc) eq 0 then begin
		  print, 'PLEASE GIVE INC ANGLE FOR EFFECTIVE VELOCITY DISPERSION'
		  return
	  endif

	  d_vrms2 = sqrt((2.*vrms_shift)^2.*(1.-2/(3.*sin(inc*!dtor)^2.))^2 $
		  *dvrms_shift^2.+ (2.*vrms_obs)^2.*(2/(3.*sin(inc*!dtor)^2.))^2. $
		  *dvrms_obs^2.)
	  d_vrms = 1/2.*(vrms^2.)^(-0.5)*d_vrms2
    endif
  endelse

  logvrms=alog10(vrms)
  d_logvrms=1./alog(10.)*d_vrms/vrms
  d_logvrms_mad = 1./alog(10.)*(d_vrms/mad_to_sig)/vrms

  index=where(finite(d_Lum) and finite(d_logR) and finite(d_logvrms), ct) ; cloud peaknum = 1394 has d_logR = NaN 

  logR = logR[index]
  logvrms = logvrms[index]
  logLum = logLum[index]
  d_logR = d_logR[index]
  d_logvrms = d_logvrms[index]
  d_logLum = d_logLum[index]

  d_logR_mad = d_logR_mad[index]
  d_logvrms_mad = d_logvrms_mad[index]
  d_logLum_mad = d_logLum_mad[index]

  print, 'herehere'


  distance = distance[index]

  ; check_arr = make_array(n_elements(distance), /INTEGER, VALUE = 1)
  if n_elements(inner_pc) gt 0 then begin
    inner_ind=where(distance le inner_pc, inner_ct)
    ring_ind=where((distance gt ring_pc[0]) and (distance le ring_pc[1]),ring_ct)
    outer_ind=where((distance gt outer_pc[0]) and (distance le outer_pc[1]), outer_ct)
    all_ind = where(distance gt 0, all_ct)
    ; check_arr[inner_ind]=0
    ; check_arr[ring_ind]=0
    ; check_arr[outer_ind]=0
    ; rest_ind = where(check_arr eq 1, rest_ct)
  endif
  ; print, inner_ct, ring_ct, outer_ct, inner_ct+ring_ct+outer_ct, n_elements(distance) ; equal

  print, 'fitting sample: ', 'all_ind', n_elements(all_ind)
  pick_ind = all_ind ; outer_ind, ring_ind, inner_ind, all_ind ; to fit different regions, change this line manually


; TYPICAL UNCERTAINTIES in figures
  md_logR = median(d_logR_mad)
  md_logvrms = median(d_logvrms_mad)
  md_logLum = median(d_logLum_mad)

  ; print, 'median error R:', median(d_R), ' median error sigma:', median(d_vrms)

; FIT LOG(vrms) VS LOG(R) WITH ERROR

  if ~keyword_set(nofitting) then begin
  linmix_err, logR[pick_ind], logvrms[pick_ind], post0, xsig=d_logR[pick_ind], ysig=d_logvrms[pick_ind], $
	  delta=del, /silent , metro=1

  slope0=post0.beta
  zp0=post0.alpha
  corr0=post0.corr

  ; plothist, /noplot, slope0, slope_xbin0, slope_ybin0, bin=0.001, xst=1, ystyle=4 ; /noplot added by Eric
  ; fit_result0=gaussfit(slope_xbin0, slope_ybin0, slope_A0, nterms=3)
  ; plothist, /noplot, zp0, zp_xbin0, zp_ybin0, bin=0.001, xst=1, ystyle=4
  ; fit_result0=gaussfit(zp_xbin0, zp_ybin0, zp_A0, nterms=3)

  slope_A0 = [0, median(slope0), mad(slope0)]
  zp_A0 = [0, median(zp0), mad(zp0)]

endif 

  ; sixlin, logR, logvrms, a0, siga0, b0, sigb0

  corr0 = (r_correlate(logR[pick_ind], logvrms[pick_ind]))[0]
  print, '******************************************************'
  print, 'VRMS - R RELATION:'
  print, 'SLOPE OF LOG(R) VS. LOG(VRMS):', slope_A0[1], '+/-', $
	  slope_A0[2]
  print, 'ZP OF LOG(R) VS. LOG(VRMS):', zp_A0[1], '+/-', $
	  zp_A0[2]
  print, 'SPEARMANN RANK CORRELATION COEFFICIENT:', corr0
  ; print, 'check if it is using default values ', slope_A0[0]
  print, '******************************************************'




; ; FIT LOG(R) VS LOG(LUM) WITH ERROR
; if ~keyword_set(nofitting) then begin
;   linmix_err, logR[pick_ind], logLum[pick_ind], post1, xsig=d_logR[pick_ind], ysig=d_logLum[pick_ind], $
;   	  delta=del, /silent  , metro=1

;   slope1=post1.beta
;   zp1=post1.alpha
;   corr1=post1.corr

;   ; plothist, /noplot, slope1, slope_xbin1, slope_ybin1, bin=0.001, xst=1, ystyle=4
;   ; fit_result1=gaussfit(slope_xbin1, slope_ybin1, slope_A1, nterms=3)
;   ; plothist, /noplot, zp1, zp_xbin1, zp_ybin1, bin=0.001, xst=1, ystyle=4
;   ; fit_result1=gaussfit(zp_xbin1, zp_ybin1, zp_A1, nterms=3)

;   slope_A1 = [0, median(slope1), mad(slope1)*mad_to_sig]
;   zp_A1 = [0, median(zp1), mad(zp1)*mad_to_sig]

; endif

;   corr1 = (r_correlate(logR[pick_ind], logLum[pick_ind]))[0]
;   print, '******************************************************'
;   print, 'LUM - R RELATION:'
;   print, 'SLOPE OF LOG(R) VS. LOG(LUM):', slope_A1[1], '+/-', $
;   	  slope_A1[2]
;   print, 'ZP OF LOG(R) VS. LOG(LUM):', zp_A1[1], '+/-', $
;   	  zp_A1[2]
;   print, 'SPEARMANN RANK CORRELATION COEFFICIENT:', corr1
;   print, '******************************************************'

;   ; sixlin, logR, logLum, a1, siga1, b1, sigb1
;   ;corr1 = (r_correlate(logR, logLum))[0]
;   ;print, '******************************************************'
;   ;print, 'LUM - R RELATION:'
;   ;print, 'SLOPE OF LOG(R) VS. LOG(LUM):', b1[0], '+/-', $
;   ;	  sigb1[0]
;   ;print, 'ZP OF LOG(R) VS. LOG(LUM):', a1[0], '+/-', $
;   ;	  siga1[0]
;   ;print, 'SPEARMANN RANK CORRELATION COEFFICIENT:', corr1
;   ;print, '******************************************************'



; ; FIT LOG(vrms) VS LOG(LUM) WITH ERROR

;   if ~keyword_set(nofitting) then begin
;   linmix_err, logvrms[pick_ind], logLum[pick_ind], post2, xsig=d_logvrms[pick_ind], ysig=d_logLum[pick_ind], $
; 	 delta=del, /silent , metro=1
;   slope2=post2.beta
;   zp2=post2.alpha
;   corr2=post2.corr
;   ; plothist,  /noplot, slope2, slope_xbin2, slope_ybin2, bin=0.001, xst=1, ystyle=4 ;
;   ; plothist, /noplot, zp2, zp_xbin2, zp_ybin2, bin=0.001, xst=1, ystyle=4 ; 
;   ; fit_result2=gaussfit(slope_xbin2, slope_ybin2, slope_A2, nterms=3)
;   ; fit_result2=gaussfit(zp_xbin2, zp_ybin2, zp_A2, nterms=3)
;   slope_A2 = [0, median(slope2), mad(slope2)*mad_to_sig]
;   zp_A2 = [0, median(zp2), mad(zp2)*mad_to_sig]
; endif

;   corr2 = (r_correlate(logvrms[pick_ind], logLum[pick_ind]))[0]
;   print, '******************************************************'
;   print, 'LUM - VRMS RELATION:'
;   print, 'SLOPE OF LOG(VRMS) VS. LOG(LUM):', slope_A2[1], '+/-', $
; 	 slope_A2[2]
;   print, 'ZP OF LOG(VRMS) VS. LOG(LUM):', zp_A2[1], '+/-', $
; 	 zp_A2[2]
;   print, 'SPEARMANN RANK CORRELATION COEFFICIENT:', corr2
;   print, '******************************************************'

;   ; sixlin, logvrms, logLum, a2, siga2, b2, sigb2
;   ; corr2 = (r_correlate(logvrms, logLum))[0]
;   ; print, '******************************************************'
;   ; print, 'LUM - VRMS RELATION:'
;   ; print, 'SLOPE OF LOG(VRMS) VS. LOG(LUM):', b2[0], '+/-', $
; 	 ;  sigb2[0]
;   ; print, 'ZP OF LOG(VRMS) VS. LOG(LUM):', a2[0], '+/-', $
; 	 ;  siga2[0]
;   ; print, 'SPEARMANN RANK CORRELATION COEFFICIENT:', corr2
;   ; print, '******************************************************'




; ; PLOT THE FIGURE
; !P.FONT = 1
;   set_plot, 'ps'
;   device, filename=outfile, bits_per_pixel=8, /encapsulated, $
; 		xsize=16.5, ysize=5.0, /inches, /color, xoffset=0., yoffset=0., SET_FONT='Times', /TT_FONT

;   !p.multi=[0, 3, 1]

;   ;   legend
;   title = []
;   color =[]
;   if inner_ct gt 0 then begin
;     title = [title, 'Inner GMCs']
;     color = [color, 'blue']
;   endif
;   if ring_ct gt 0 then begin
;     title = [title, 'Intermediate GMCs']
;     color = [color, 'dark_green']
;   endif
;   if outer_ct gt 0 then begin
;     title = [title, 'Outer GMCs']
;     color = [color, 'red']
;   endif

;   ; -------------------------------------
;   ; Subplot - 1. plot log(R) vs log(vrms)
;   ; -------------------------------------
;   xmin=min(logR)-0.15
;   xmax=max(logR)+0.1
;   ymin=min(logvrms)-0.1
;   ymax=max(logvrms)+0.1

;   ;   plot all data points
;   if vrmsmode eq 'obs' then ytitle = $
; 	  'log($\sigma$!Dobs,los!N'+' / km s!U-1!N)'
;   if vrmsmode eq 'turb' then ytitle = $
; 	  'log($\sigma$!Dgs,los!N'+'/km s!U-1!N)'
;   if vrmsmode eq 'eff' then ytitle = $
; 	  'log($\sigma$!Deff,los!N'+'/km s!U-1!N)'

;   if n_elements(xrange) eq 0 then xrange=[xmin,xmax]
;   if n_elements(yrange) eq 0 then yrange=[ymin,ymax+0.35]

;   cgplot, logR, logvrms, psym=9, color='black', $
; 	  xtitle='log(!8R!X!Dc!N / pc)', $
; 	  ytitle=ytitle, $
; 	  axiscolor='black', $
; 	  xrange=xrange, yrange=yrange, xst=1, yst=1, $
;       charsize = 3.5, xthick=5, ythick=5, charthick=5, $
;       pos = [0.06, 0.16, 0.33, 0.98], /nodata

;   ; cgtext, 0.02,0.30, ytitle, charsize=1.7, charthick=5,$
; 	 ;  orientation = 90,/normal

;   if outer_ct gt 0 then begin
; 	  cgoplot, logR[outer_ind], logvrms[outer_ind], psym='Filled Circle', SYMSIZE=0.5,$
; 		  color=cgColor('red')
;   endif
;   if ring_ct gt 0 then begin
;     cgoplot, logR[ring_ind], logvrms[ring_ind], psym='Filled Circle', SYMSIZE=0.5,$
;       color=cgColor('dark green')
;   endif
;   if inner_ct gt 0 then begin
;     cgoplot, logR[inner_ind], logvrms[inner_ind], psym='Filled Circle', SYMSIZE=0.5, $
;       color=cgColor('blue')
;   endif
  
;   ;   plot typical uncertainties
;   err_xpos=xmax-(xmax-xmin)/5.
;   err_ypos=ymin+(ymax-ymin)/5.
;   oploterror, err_xpos, err_ypos, md_logR, md_logvrms, $ ; modified by Eric, was once /2
; 	  pysm=0, errthick = 4.0, errcolor='black', $
; 	  hatlength=0.0, charsize = 1.3, xthick=3, ythick=3, charthick=3

;   ;   plot larson's relation for MW disc
;   x_MW = findgen(1e4)/1e4*(xmax-xmin)+xmin
;   y_MW=alog10(0.72)+0.5*x_MW
;   oplot, x_MW, y_MW, linestyle=1, thick=5.
;   ; cgoPlot, x_MW, y_MW, linestyle=1, thick=5. ; workaround, using thick=5, linestyle=1

;   ;   plot larson's relation for MW Center (Kauffmann et al. 2017)
;   x_MW = findgen(1e4)/1e4*(xmax-xmin)+xmin
;   y_MW=alog10(5.5)+0.66*x_MW
;   ; oplot, x_MW, y_MW, linestyle=1, thick=6.; original
;   cgoplot, x_MW, y_MW, linestyle=1, thick=5., color='Orange' ; , using thick=6.

;   ;   plot fitted log(R) vs log(vrms) relation
;   xline = findgen(1e4)/1e4*(xmax-xmin)+xmin
;   yline = zp_A0[1] + slope_A0[1]*xline
;   ; yline = a0[0] + b0[0]*xline
;   oplot, xline, yline, linestyle=0, thick=5.


;   cglegend,title=['NGC1387','MW disc','MW CMZ'], $ ;psym=9, symsize=1.5, length=0.0,
;        color=['black','black','Orange'], location=[0.17, 0.92], $
;        linestyle=[0,1,1], thick=5.,$
;       VSpace=2.0, charsize=1.8, charthick=5.0
  


;   ; -------------------------------------
;   ; Subplot - 2. plot log(R) vs log(Lum)
;   ; -------------------------------------
;   ;   plot all data points
;   xmin=min(logR)-0.1
;   xmax=max(logR)+0.1
;   ymin=min(logLum)-0.3
;   ymax=max(logLum)+0.3

;   cgplot, logR, logLum, psym=9, color='black', $
; 	  xtitle='log(!8R!X!Dc!N / pc)', $
; 	  ytitle='log(!8L!X!DCO(2-1)!N / K km s!U-1!N pc!U2!N)', $
; 	  axiscolor='black', $
; 	  xrange=[xmin,xmax], yrange=[ymin, ymax], xst=1, yst=1, $ ; xmin, xmax]
;       charsize = 3.5, xthick=5, ythick=5, charthick=5, $
;       pos = [0.39, 0.16, 0.66, 0.98], /nodata

;   if outer_ct gt 0 then begin
;     cgoplot, logR[outer_ind], logLum[outer_ind], psym='Filled Circle', SYMSIZE=0.5, $
;       color=cgColor('red')
;   endif
;   if ring_ct gt 0 then begin
; 	  cgoplot, logR[ring_ind], logLum[ring_ind], psym='Filled Circle', SYMSIZE=0.5, $
; 		  color=cgColor('dark green')
;   endif
;   if inner_ct gt 0 then begin
;     cgoplot, logR[inner_ind], logLum[inner_ind], psym='Filled Circle', SYMSIZE=0.5, $
;       color=cgColor('blue')
;   endif
  
;   ;   plot typical uncertainties
;   err_xpos=xmax-(xmax-xmin)/5.
;   err_ypos=ymin+(ymax-ymin)/5.
;   oploterror, 1.5, err_ypos, md_logR, md_logLum, $ ; modified by Eric, was once /2
; 	  pysm=0, color='red', errthick = 4.0, errcolor='black', $
; 	  hatlength=0.0, charsize = 1.3, xthick=3, ythick=3, charthick=3

;   ;   plot larson's relation for MW
;   x_MW = findgen(1e4)/1e4*(xmax-xmin)+xmin
;   y_MW = alog10(25.)+2.5*x_MW
;   oplot, x_MW, y_MW, linestyle=1, thick=5.
;   ; cgoplot, x_MW, y_MW, linestyle=1, thick=5.

;   ;   plot larson's relation for MW Center (Li et al. 2020 apj 897 89)
;   x_MW = findgen(1e4)/1e4*(xmax-xmin)+xmin
;   y_MW=alog10(1000./alpha_co)+3.*x_MW
;   cgoplot, x_MW, y_MW, linestyle=1, thick=5., color='Orange'

;   ;   plot fitted log(R) vs log(Lum) relation
;   xline = findgen(1e4)/1e4*(xmax-xmin)+xmin
;   yline = zp_A1[1]+slope_A1[1]*xline
;   ; yline = a1[0]+b1[0]*xline
;   oplot, xline, yline, linestyle=0, thick=5. ; used 3



;   ; cglegend,title=[title], psym=[16,16,16], $
;   ;     symsize=0.8, color=[color], location=[0.42, 0.88], $
;   ;     length=0.0, linestyle=2, thick=5.,$
;   ;     VSpace=2.0, charsize=2.0, charthick=5.0

;   ; -------------------------------------
;   ; Subplot - 3. plot log(vrms) vs log(Lum)
;   ; -------------------------------------
;   ;   plot all data points
;   xmin=min(logvrms)-0.1
;   xmax=max(logvrms)+0.1
;   ymin=min(logLum)-0.3
;   ymax=max(logLum)+0.3

;   cgplot, logvrms, logLum, psym=9, color='black', $
; 	  xtitle='log($\sigma$!Dobs,los!N / km s!U-1!N)', $
; 	  ytitle='log(!8L!X!DCO(2-1)!N / K km s!U-1!N pc!U2!N)', $
; 	  axiscolor='black', $
; 	  xrange=[xmin, xmax], yrange=[ymin, ymax], xst=1, yst=1, $
;       charsize = 3.5, xthick=5, ythick=5, charthick=5, $
;       pos = [0.72, 0.16, 0.99, 0.98], /nodata

;   if outer_ct gt 0 then begin
;     cgoplot, logvrms[outer_ind], logLum[outer_ind], psym='Filled Circle', SYMSIZE=0.5,  $
;       color=cgColor('red')
;   endif
;   if ring_ct gt 0 then begin
; 	  cgoplot, logvrms[ring_ind], logLum[ring_ind], psym='Filled Circle', SYMSIZE=0.5,  $
; 		  color=cgColor('dark green')
;   endif
;   if inner_ct gt 0 then begin
;     cgoplot, logvrms[inner_ind], logLum[inner_ind], psym='Filled Circle', SYMSIZE=0.5,  $
;       color=cgColor('blue')
;   endif
  
;   ;   plot typical uncertainties
;   err_xpos=xmax-(xmax-xmin)/5.
;   err_ypos=ymin+(ymax-ymin)/5.
;   oploterror, err_xpos, err_ypos, md_logvrms, md_logLum, $ ; modified by Eric, was once /2
; 	  pysm=0, color='red', errthick = 4.0, errcolor='black', $
; 	  hatlength=0.0, charsize = 1.3, xthick=3, ythick=3, charthick=3

;   ; oploterror, logvrms[inner_ind], logLum[inner_ind], d_logvrms[inner_ind], d_logLum[inner_ind], $
;   ;   pysm=0, color='red', errthick = 4.0, errcolor='black', $
;   ;   hatlength=0.0, charsize = 1.3, xthick=3, ythick=3, charthick=3

;   ;   plot larson's relation for MW
;   x_MW = findgen(1e4)/1e4*(xmax-xmin)+xmin
;   y_MW = alog10(130.)+5.*x_MW
;   oplot, x_MW, y_MW, linestyle=1, thick=5. ; used 3
;   ; cgoplot, x_MW, y_MW, linestyle=1, thick=5.

;   ;   plot fitted log(vrms) vs log(Lum) relation
;   xline = findgen(1e5)/1e5*(xmax-xmin)+xmin
;   yline = zp_A2[1]+slope_A2[1]*xline ; linmix_error
;   ; yline = a2[0]+b2[0]*xline ; sixlin
;   oplot, xline, yline, linestyle=0, thick=5. ; used 3
;   ; print, [a2,b2]

; cglegend,title=[title], psym=[16,16,16], $
;       symsize=0.8, color=[color], location=[0.75, 0.92], $
;       length=0.0, linestyle=2, thick=5.,$
;       VSpace=2.0, charsize=2.0, charthick=5.0


;   device, /close_file
;   set_plot, 'X'

end
