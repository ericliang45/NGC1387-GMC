PRO cpropstoo_alpha_figure_app, intable = intable $
                       , inner_pc = inner_pc $
                       , ring_pc = ring_pc $
                       , outer_pc = outer_pc $
					   , inprop = inprop $
					   , vrmsmode = vrmsmode $
					   , shear_table = shear_table $
					   , plotval = plotval $
					   , hist_xrange = hist_xrange $
	                   , outfile = outfile $
                         , nofitting=nofitting $
                          , checkfile_re = checkfile_re $ 
                            , alpha_co = alpha_co
	                 

;+
; NAME: 
;   cpropstoo_alpha_figure
;
; PURPOSE:
;   Generate a figure showing the reation between Mlum and Mvir,
;   and distribution of virial parameter (the ratio between twice the 
;   kinetic energy and the gravitational energy (Mvir/Mlum)
;   
; INPUTS:
;   intable  --  the table of gmc properties generated by 'cpropsdist_gmc_table.pro'
;   inprop   --  the '.idl' file for GMC properties generated by 'moments_to_props'
;   vrmsmode --  vrms mode: "obs", "turb", "eff"
;   shear_table -- the table including shear parameters generated by 
;                  "cpropstoo_shear_table.pro"
;   plotval  -- the range of plot, plotval = [minval, maxval]
;   hist_xrange -- the xrange of log(alpha) histogram 
;    
; OUTPUTS:
;   outfile  --  the '.eps' file for output figure
; 
; HISTORY:
;   20170219  LJ   introduced

; HEAD MESSAGE
  print, '======================================================'
  print, 'CPROPSTOO: GENERATE FIG OF CORRELATION BETWEEN VIRIAL'
  print, '            AND LUMINOUS MASSES OF GMCS'
  print, '======================================================'

; ; Derive Mlum and Mvir and their uncertainties
;   readcol,intable, ID, RA, Dec, Vlsr, R, d_R, vrms, d_vrms, vturb, d_vturb, $
; 	      Lum, d_Lum, Mlum, d_Mlum, Tmax, Omega_shear, Theta_shear,distance, $
; 		  F='I, a, a, f, f, f, f, f, f, f, f, f, f, f, f, f, f, f'
;   Mlum = Mlum *1e5
;   d_Mlum = d_Mlum *1e5
;   Lum = Lum * 1e4
;   d_Lum = d_Lum * 1e4


;   res_inds=where(R gt 0.0, resolve_ct)
;   print, 'Resoved Clouds: '+string(resolve_ct,format='(I)')+' GMCs'

;   ; Luminose Mass
;   Mlum = Mlum[res_inds]
;   d_Mlum = d_Mlum[res_inds]
;   distance = distance[res_inds]

array_re = fltarr(file_lines(checkfile_re))
openr, lun, checkfile_re, /get_lun
readf, lun, array_re
free_lun, lun

resolve_ind = where( array_re gt 0.5, res_ct)


  ; Viral mass
  if n_elements(vrmsmode) eq 0 then begin
    vrmsmode = "obs"
 ;    vrms=vrms[res_inds]
 ;    d_vrms=d_vrms[res_inds]
	sub_xtitle = 'log $\alpha$!Dobs,los!N' ;'log $\alpha$!Dobs,vir!N'
endif
 ;  endif else begin
 ;    if vrmsmode eq "turb"  then begin
 ;      vrms=vturb[res_inds]
 ;      d_vrms=d_vturb[res_inds]
	;   sub_xtitle = 'log $\alpha$!Dgs,vir!N'
 ;    endif
 ;    if vrmsmode eq "eff"  then begin
	;   readcol, shear_table, ID, Omega, T, vrms_eff, dvrms_eff, $
	;               vrms_pred, vir_eff, OmegaStd, TStd, F='I,f,f,f,f,f,f,f,f'
 ;      vrms=vrms_eff[res_inds]
 ;      d_vrms=vrms_eff * d_vrms/vrms
 ;      d_vrms = d_vrms[res_inds]
	;   sub_xtitle = 'log $\alpha$!Deff,vir!N'
 ;    endif
 ;  endelse

  restore, inprop

  print, alpha_co

  ; resolve_ind = where( props.resolve_spatial * props.resolve_spectral eq 1.0 )

  mad_to_sig = 1.0 ; 1.4826
  Mvir = (props.VIRMASS_EXTRAP_DECONV)[resolve_ind] 
  ; moments_classic.pro: props.vircoeff*props.radrms_extrap_deconv*props.vrms_extrap_deconv^2; props.vircoeff=1/(G bs) = 1162[unit]
  d_Mvir = (props.VIRMASS_EXTRAP_DECONV_UC)[resolve_ind] * Mvir * mad_to_sig ; mad * 1.4826 = sigma

  ; Mlum = (props.MASS_EXTRAP)[resolve_ind] ; alpha_co used in cprops run was 5.0, but then changed to 4.8 (with the latest pymakeplots) and can potentially change in the future too
  Mlum = (props.mom0_extrap*props.chanwidth_kms*(props.pcperpix)^2*alpha_co)[resolve_ind]
  ; checked, cloud['mom0_extrap'] * cloud['chanwidth_kms'] * cloud['pcperpix']**2 = cloud['lum_extrap']
  d_Mlum = (props.MASS_EXTRAP_UC)[resolve_ind] * Mlum * mad_to_sig

  distance = (props.r_gal)[resolve_ind]

  ; R = (props.radrms_extrap_deconv)[[resolve_ind]]
  ; vrms = (props.vrms_extrap_deconv)[resolve_ind]
  ; Mvir = 1160. * R * vrms^2.

  ; Mvir = 1160. * R[res_inds] * vrms^2.
  ; ;Mvir = 1040. * R[res_inds] * vrms^2.
  ; d_Mvir_frac = (props.VIRMASS_EXTRAP_DECONV_UC)[res_inds]
  ; d_Mvir = Mvir * abs(d_Mvir_frac)


  logMlum=alog10(Mlum)	
  d_logMlum=1./alog(10.)*d_Mlum/Mlum
  logMvir=alog10(Mvir)	
  d_logMvir=1./alog(10.)*d_Mvir/Mvir

  d_logMlum_mad = 1./alog(10.)*(d_Mlum/mad_to_sig)/Mlum
  d_logMvir_mad =1./alog(10.)*(d_Mvir/mad_to_sig)/Mvir

  alpha = Mvir/Mlum
  log_alpha = alog10(alpha)

  ind = where(finite(logMlum) and finite(logMvir) and finite(d_logMlum) $
	  and finite(d_logMvir), ct)
    ; print, n_elements(logMlum)
    ; print, ct ; cloud peaknum = 1394, 1077, 600, 522 have d_logMvir=NaN due to d_logR = NaN (three more than the main catalogue)
  logMlum = logMlum[ind]
  logMvir = logMvir[ind]
  d_logMlum = d_logMlum[ind]
  d_logMvir = d_logMvir[ind]
  print, n_elements(logMlum)

  d_logMlum_mad= d_logMlum_mad[ind]
  d_logMvir_mad= d_logMvir_mad[ind]

  distance = distance[ind]

  inner_ind=where(distance le inner_pc, inner_ct)
  ring_ind=where((distance gt ring_pc[0]) and (distance le ring_pc[1]),ring_ct)
  outer_ind=where((distance gt outer_pc[0]) and (distance le outer_pc[1]), outer_ct)

  md_logMlum = median(d_logMlum_mad)
  md_logMvir = median(d_logMvir_mad)


  if keyword_set(nofitting) then begin
  a = [0, -2.6374520 ] ; intercept
  b = [0,  1.4952341] ; slope
  siga =[0,  0.18171110 ] 
  sigb = [0,  0.033418674]
  slope_A =[0, 0.829596, 0.0304026]
  zp_A = [0, 1.02760, 0.172370]
endif else begin

  ; linear fit Mvir vs Mlum

  sixlin, logMlum, logMvir, a, siga, b, sigb

  linmix_err, logMlum, logMvir, post, $
	  xsig=d_logMlum, ysig=d_logMvir, /silent, miniter=2000

  slope=post.beta
  zp=post.alpha
  sigsqr=post.sigsqr

  ; Simple statistics method. Less preferred in this script
  ; slope_A = [0, median(slope), mad(slope)]
  ; zp_A = [0, median(zp), mad(zp)]

  ; Gaussian method, preferred in this script
  plothist, slope, slope_xbin, slope_ybin, bin=0.001, xst=1, ystyle=4
  fit_result=gaussfit(slope_xbin, slope_ybin, slope_A, NTERMS=3)

  plothist, zp, zp_xbin, zp_ybin, bin=0.001, xst=1, ystyle=4
  fit_result=gaussfit(zp_xbin, zp_ybin, zp_A, nterms=3)
  ; End of Gaussian method

  ; plothist, sigsqr, sigsqr_xbin, sigsqr_ybin, bin=0.00001, xst=1, ystyle=4
  ; fit_result=gaussfit(sigsqr_xbin, sigsqr_ybin, sigsqr_A, nterms=3)
endelse

  print,'============================================================='
  print,'sixlin fit of logMvir vs logMlum:', a[1], '+/-', siga[1], b[1], '+/-', sigb[1]
  print,'slope, zp from linmix_err fitting:',slope_A[1],'+/-', $ 
	  slope_A[2], ',', zp_A[1], '+/-', zp_A[2]
  theind = where(log_alpha ge alog10(1.), thect)
  print,'fraction of clouds with alpha > 1.:', thect/(n_elements(log_alpha)*1.0)
  theind = where(log_alpha ge alog10(2.), thect)
  print,'fraction of clouds with alpha > 2.:', thect/(n_elements(log_alpha)*1.0)
  theind = where(log_alpha lt alog10(2.) and log_alpha gt alog10(0.5), thect)
  print,'fraction of clouds with alpha > 0.5 & < 2.0:', thect/(n_elements(log_alpha)*1.0)
  print, slope_A[0], ' check if it is using default values'
  print,'============================================================='



; Plot Mlum vs. Mvir
  
  !P.FONT = 1 ; 0 designates the device (PS) font, 1 for TrueFont
  set_plot,'ps'
  device, filename=outfile, bits_per_pixel=8, /encapsulated, $
		xsize=4.5, ysize=4.5, /inches, /color, xoffset=0, yoffset=0 , SET_FONT='Times', /TT_FONT
  ; DEVICE, SET_FONT = 'Times-Italic', FONT_INDEX=8
  ; HELP, /DEVICE

  !p.multi = [0, 2, 1, 0, 0]

  ; 1) plot logMlum vs. logMvir
  ;xmax=max(logMlum + d_logMlum)+0.2
  ;xmin=min(logMlum - d_logMlum)-0.2
  ;ymax=max(logMvir + d_logMvir)+0.2
  ;ymin=min(logMvir - d_logMvir)-0.2
  xmax=max(logMlum+d_logMlum/2.) 
  xmin=min(logMlum-d_logMlum/2.)
  ymax=max(logMvir+d_logMvir/2.)
  ymin=min(logMvir-d_logMvir/2.)
  
  if n_elements(plotval) eq 0 then begin
    maxval = max([xmax, ymax])
    minval = min([xmin, ymin])
    dval = maxval - minval
    maxval = maxval + dval/3.0
    minval = minval - dval/3.0
  endif else begin
	minval = plotval[0]
	maxval = plotval[1]
  endelse
	
  

  if vrmsmode eq 'obs' then ytitle='log(!8M!X!Dobs,vir!N / M!D!10!Z(2609)!X!N)' ;

  ; if vrmsmode eq 'turb' then ytitle='log(M!Dgs,vir!N/M'+sunsymbol()+')'
  ; if vrmsmode eq 'eff' then ytitle='log(M!Deff,vir!N/M'+sunsymbol()+')'

  ; ploterror, logMlum, logMvir, d_logMlum, d_logMvir, psym=3, errthick=1, $
	 ;  ;ytitle='log(M!Dvir!N/M'+sunsymbol()+')', $
	 ;  ytitle=ytitle, $
	 ;  ;xtitle='log(M!Dgas!N/M'+sunsymbol()+')', $
	 ;  charsize = 1.7, xthick=5, ythick=5, charthick=5, $
	 ;  xrange=[minval,maxval], yrange=[minval,maxval],xst=1,yst=1, $
  ;     position = [0.14,0.15, 0.98, 0.98], /nodata

  ; cgplot, 6.5, 5.5, ERR_XLow=md_logMlum, ERR_YLow=md_logMvir, ytitle='$\sun$', position = [0.14,0.15, 0.98, 0.98], $
    ; xrange=[3.9,7.2], yrange=[3.9,7.2]

  ; p = ERRORPLOT([6.6], [5.6], [md_logMvir], [md_logMlum], position = [0.14,0.15, 0.98, 0.98],xrange=[3.9,7.1], yrange=[3.9,7.1])
  
  ploterror, 6.6, 5.6, md_logMlum, md_logMvir, psym=3, errthick=4, $ 
     charsize = 0.0, xthick=5, ythick=5, charthick=5, $ ; charsize = 2.0
      xrange=[3.9,7.1], yrange=[3.9,7.1],xst=1,yst=1, position = [0.,0., 1.0, 1.0], $ ; [minval, maxval][0.3,0.3, 0.9, 0.9]
    hatlength=0.0
    ; , ytitle=ytitle, xtitle='log(!8M!X!Dgas!N / M'+sunsymbol()+'!N)'

  loadct,33
  plotsym,0,/fill
  ;oplot, logMlum, logMvir, psym=9, thick=3, color=cgcolor('black')
  loadct, 0
  ; cgtext, 0.40, 0.03, 'log(!8M!X!Dc!N / M'+sunsymbol()+'!N)', $
  ;     charsize=1.7, charthick=5,/normal

  ; cgtext, 6.52,6.6,'!N$\alpha$!Dobs,los!N = 1',  ORIENTATION=45, charsiz=1.3
  ; cgtext, 6.22,6.6,'!N$\alpha$!Dobs,los!N = 2',  ORIENTATION=45, charsiz=1.3

  if outer_ct gt 0 then $
     cgoplot, logMlum[outer_ind], logMvir[outer_ind], psym='Filled Circle', SYMSIZE=0.5,$
      thick=3, color=cgColor('red')

  if ring_ct gt 0 then $
     cgoplot, logMlum[ring_ind], logMvir[ring_ind], psym='Filled Circle', SYMSIZE=0.5,$
			thick=3, color=cgColor('dark green')

  if inner_ct gt 0 then $
     cgoplot, logMlum[inner_ind], logMvir[inner_ind], psym='Filled Circle',  SYMSIZE=0.5, $
      thick=3, color=cgColor('blue')

  ; legend
  title = []
  color =[]
  if inner_ct gt 0 then begin
      title = [title, 'Inner GMCs']
      color = [color, 'blue']
  endif
  if ring_ct gt 0 then begin
      title = [title, 'Intermediate GMCs']
      color = [color, 'dark_green']
  endif
  if outer_ct gt 0 then begin
      title = [title, 'Outer GMCs']
      color = [color, 'red']
  endif

  ; cglegend,title=[title], psym=[16,16,16], linestyle=[6,6,6], $ ; ,'Median error' ... ,1 ... ,6
  ;     symsize=1.0, color=[color], location=[0.2, 0.9], $ ; ,'black'
  ;     length=0.0, thick=4.,$
  ;     VSpace=1.8, charsize=1.8, charthick=3.0

  ; cglegend,title=['Fitting'], $ ;psym=9, symsize=1.5, length=0.0,
  ;      color=['black'], location=[0.19, 0.8], $
  ;      linestyle=[0], thick=5.,$
  ;     VSpace=1.5, charsize=1.8, charthick=3.0

  ; 2) plot equal - line
  x = findgen(1e4)/(1e4-1.)*(maxval-minval)+minval
  y = x
  oplot, x, y, psym=0, thick=3, color=cgcolor('black'), $
	  linestyle = 2

  ; 2) plot twice - line
  x = findgen(1e4)/(1e4-1.)*(maxval-minval)+minval
  y = x + alog10(2)
  oplot, x, y, psym=0, thick=3, color=cgcolor('black'), $
    linestyle = 1 ; dotted

  ;    plot fited line
  ; y = b[1]*x + a[1]
  y = slope_A[1] * x + zp_A[1]
  oplot, x, y, psym=0, thick=3, color=cgcolor('black')

  ; 3) plot alpha distribution
  ;binsize=(max(log_alpha)-min(log_alpha))/10.
  ;binsize = 0.06
  ;if (vrmsmode eq 'eff') then binsize = 0.1
  binsize=(max(log_alpha)-min(log_alpha))/20.
  yhist = histogram(log_alpha, binsize=binsize, min=min(log_alpha), $
	  max=max(log_alpha), locations=binvals)
  ;    Gauss fit
  yfit = gaussfit(binvals+binsize/2., yhist, A, sigma=eA, nterms=3)
  xgauss = findgen(1e4)/(1e4-1.)*(max(binvals)-min(binvals)+0.4) $
	  +min(binvals)-0.2
  z = (xgauss-A[1])/A[2]
  ygauss=A[0]*EXP(-z^2/2.) 

  print, '==================='
  print, 'alpha:', 10.^(A[1])
  print, 'sigma of log(alpha):', A[2]
  print, 'd_alpha+:', 10.^(A[1]+eA[1])-10.^(A[1])
  print, 'd_alpha-:', 10.^(A[1])-10.^(A[1]-eA[1])
  print, '==================='

  x_vertical = make_array(1e3) + A[1]
  y_vertical = findgen(1e3)/1e3*(max(yhist)*1.2)
  
  print, 'auto x tick interval: ',floor((max(binvals)+0.2 - (min(binvals)-0.2))/5.*10)/10.
  tickinterval = 1.0 ;floor((max(binvals)+0.2 - (min(binvals)-0.2))/5.*10)/10.
  if n_elements(hist_xrange) eq 0 then $
	  hist_xrange=[min(binvals)-0.2,max(binvals)+0.2]
  print,'hist_xrange',hist_xrange
  loadct, 33

  plothist, log_alpha, bin = binsize, axiscolor = 'black', $
	  color = cgcolor('black'), $
       boxplot = 0, thick = 4, $
	   ; xtitle=sub_xtitle, ytitle = 'No. of GMCs', $
	   charsize=1.6, xthick =4.0, ythick=4.0, charthick=8.0, $
       position = [0.72,0.15,0.96,0.4], $
       xtickinterval=tickinterval, ytickinterval=50,xminor=floor(tickinterval/0.1), $
	   xticklen=0.08, yticklen=0.06, $
	   xrange=[-1.3,1.3], yrange=[0.0, max(yhist)*1.1] ; hist_xrange

  ; cgtext, 0.73, 0.18, sub_xtitle, charsize=1.2, $
	 ;  charthick = 4, orientation = 0, /normal
  ; cgtext, 0.59, 0.24, 'Number of clouds', charsize=0.9, $
	 ;  charthick = 4, orientation = 90, /normal
  oplot, xgauss, ygauss, psym=0, thick=3, color=220
  ; loadct, 0
  oplot, x_vertical, y_vertical, linestyle=2, thick=4.

  device, /close_file
  set_plot, 'X'

END
