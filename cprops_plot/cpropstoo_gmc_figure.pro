PRO cpropstoo_gmc_figure, infile=infile, inmask=inmask, $
	                   inprop=inprop, inpmom=inpmom, $
					   impad = impad, $
					   barpos = barpos, $
					   labelpos = labelpos, $
					   scale_label=scale_label, $
					   outfits=outfits, $
					   plcloudNr = plcloudNr, $
            particular = particular, $ ; added by Eric
					   nlevels = nlevels, $
					   plellradius = plellradius, $
					   ingalpar = ingalpar, $
					   inassign = inassign, $
					   log = log, $
					   Tclip = Tclip, $
	                   outfile=outfile, $
                      checkfile_re = checkfile_re, $
                        checkfile_unre = checkfile_unre


;+
; NAME: 
;   cpropstoo_GMC_figure
;
; PURPOSE:
;   Generate a figure showing the position, measured major and 
;   minor axis of GMCs
;   
; INPUTS:
;   infile   --  corrected data fits
;   inmask   --  the mask cube of bright emission generated by "make_cprops_mask"
;   inprop  --  the '.idl' file for GMC properties generated by 'moments_to_props'
;   inpmom   --  the '.idl' file for GMC moments generated by 'cube_to_moments'
;   impad    --  the expand edges of image in X/Y directions [xdown, xup,
;                yleft, yright] in pixel ;
;   barpos   --  the position of color bar [x1,y2,x2,y2], default is
;				 barpos=[0.10, 0.85, 0.55, 0.89]
;   labelpos --  the position of label '(un)resolved clouds' [xc1,yc1,xc2,yc2]
;   scale_label -- string ("500pc" or "100pc") to label the length of "500pc"
;                 or "100pc", default to "100pc"
;   plcloudNR  -- set this keyword to plot ID of each cloud
;   plellradius -- a list of radii in [pc] to plot different regions in galaxy
;   ingalpar    -- the dat file of galaxy parameters
;
;    
; OUTPUTS:
;   [outfits] -- the output fits for masked mom0 image 
;   outfile  --  the '.eps' file for output figure
; 
; HISTORY:
;   20170208  LJ   introduced

; HEAD MESSAGE
  print, '======================================='
  print, 'CPROPSTOO: GENERATE M0 AND GMC FIGURE'
  print, '======================================='

; READ DATA CUBE
  if n_elements(infile) gt 0 then begin
	  file_data = file_search(infile, count=file_ct)
	  if file_ct eq 0 then begin
		  message, "Infile not found.", /info
		  return
	  endif else begin
		  data=readfits(infile,hdr)
	  endelse	  
  endif	  

  if n_elements(impad) eq 0 then begin
	  impad = [30, 30, 30, 30]
  endif

  if n_elements(impad) eq 2 then begin
	  impad = [impad[0], impad[0], impad[1], impad[1]]
  endif

; added by Eric
 if n_elements(particular) eq 0 then particular=[]

  ;extract header information
  radiohead, hdr, s=h0

  ;read ingalpar
  pa=0.0
  inc = 0.0
  ra_c = ''
  dec_c = ''
  dist_pc = 0.0
  blank = ''
  vsys = 0.0
  
  openr,lun,ingalpar,/get_lun
  readf,lun,blank
  readf,lun,blank
  readf,lun,blank
  readf,lun,blank
  readf,lun,pa
  readf,lun,blank
  readf,lun,inc
  readf,lun,blank
  readf,lun,blank
  readf,lun,blank
  readf,lun,ra_c
  readf,lun,blank
  readf,lun,dec_c
  readf,lun,blank
  readf,lun,dist_pc
  readf,lun,blank
  readf,lun,vsys

  close,lun
  free_lun,lun
  
array_re = fltarr(file_lines(checkfile_re))
openr, lun, checkfile_re, /get_lun
readf, lun, array_re
free_lun, lun

array_unre = fltarr(file_lines(checkfile_unre))
openr, lun, checkfile_unre, /get_lun
readf, lun, array_unre
free_lun, lun


  if ((pa eq 0.) and (ra_c eq 0.) and (dec_c eq 0.)) then begin
      print, 'Error: Wrong galaxy name, or No records for the galaxy !'
      return
  endif

; READ MASK FITS FILE
  if n_elements(inmask) gt 0 then begin
	  file_mask = file_search(inmask, count=file_ct)
	  if file_ct eq 0 then begin
		  message, "Infile not found.", /info
		  return
	  endif else begin
		  mask=readfits(inmask, mask_hdr)
	  endelse	  
  endif	  

; GENERATE 2D IMAGE AND IMHD
  index=where(mask gt 0)
  data_copy=data
  data=data*0.0
  ;data=!values.f_nan
  data[index]=data_copy[index]
  
  ; extracted image
  if strmatch(sxpar(hdr,'CUNIT3'),'*KM/S*') or $
            strmatch(sxpar(hdr,'CUNIT3'),'*km/s*') then begin 
            chanelwidth = abs(h0.cdelt[2])  ;in [km/s]
  endif else begin
      if strmatch(sxpar(hdr,'CUNIT3'),'*M/S*') or $
            strmatch(sxpar(hdr,'CUNIT3'),'*m/s*') then $
            chanelwidth = abs(h0.cdelt[2])/1e3  ;in [km/s]
  endelse

  im=total(data,3,/nan)*chanelwidth    ;in [Buit.km/s]

  mask2d = total(mask, 3, /nan)
  xmin = (where(total(mask2d, 2, /nan) gt 0))[0]
  xmax = (where(total(mask2d, 2, /nan) gt 0))[-1]
  ymin = (where(total(mask2d, 1, /nan) gt 0))[0]
  ymax = (where(total(mask2d, 1, /nan) gt 0))[-1]

  szim = size(im)
  ;xpad = xmin < impad[0] < (szim[1]-1-xmax)
  ;ypad = ymin < impad[1] < (szim[2]-1-ymax)
  xpad1 = xmin < impad[0] 
  xpad2 = impad[1] < (szim[1]-1-xmax)
  ypad1 = ymin < impad[2] 
  ypad2 = impad[3] < (szim[2]-1-ymax)
  im = im[xmin-xpad1:xmax+xpad2, ymin-ypad1:ymax+ypad2]


  ; modify header
  imhd=hdr
  bunit=SXPAR(hdr, 'BUNIT')
  CRPIX1=SXPAR(hdr, 'CRPIX1')
  CRPIX2=SXPAR(hdr, 'CRPIX2')
  sxaddpar, imhd, 'BUNIT', strtrim(bunit,2)+' km/s', before='HISTORY'
  sxaddpar, imhd, 'NAXIS1', xmax-xmin+xpad1+xpad2+1, before='HISTORY'
  sxaddpar, imhd, 'CRPIX1', CRPIX1-(xmin-xpad1), before='HISTORY'
  sxaddpar, imhd, 'NAXIS2', ymax-ymin+ypad1+ypad2+1, before='HISTORY'
  sxaddpar, imhd, 'CRPIX2', CRPIX2-(ymin-ypad1), before='HISTORY'
  sxaddpar, imhd, 'NAXIS3', 1L, before='HISTORY'
  if n_elements(outfits) gt 0 then begin
     writefits, outfits, im, imhd
  endif
  
; PLOT IMAGE MOM0
  ; set_plot,'X'
  !P.FONT = 1

  set_plot,'ps'
  device, filename=outfile, bits_per_pixel=8, /encapsulated, $
	  xsize=11.0, ysize=11.0, /inch, /color, xoffset=0, yoffset=0, /TT_FONT, SET_FONT='Times' ; SET_FONT='Times',

  !p.thick = 1.5
  !x.thick = 1.5
  !y.thick = 1.5
  !z.thick = 1.5
  !p.charsize = 1.0
  !p.charthick = 1.5
  ; xyouts, '!6'

  pos=[0.10,0.10,0.92,0.92]

  ; Tclip?
  if n_elements(Tclip) gt 0 then begin
	  if keyword_set(log) then begin
		print,'Error: Tclip and log can not be set together!'
	  endif else begin
	    ; Rosolowsky & Leroy 2006
	    ind = where(im ge Tclip, ct)
	    if ct gt 0 then im[ind] = Tclip*(1+atan(im[ind]/Tclip-1.))
	  endelse
  endif


  ; COLOR SCALING
  cgloadct,3,/SILENT,/reverse,clip=[30,255]
  if n_elements(nlevels) eq 0 then $
	  nlevels = 15
  ;reverse_CT
  if keyword_set(log) then begin
	nan_ind = where(im eq 0.0, nan_ct)
	if nan_ct gt 0.0 then $
		im[nan_ind] = !values.f_nan
    minvalue=min(alog10(im),/nan)
    maxvalue=max(alog10(im),/nan)
    if minvalue eq maxvalue then begin
	  minvalue=-1 & maxvlaue=1
    endif
	minvalue = minvalue-(maxvalue - minvalue)/nlevels
    CGIMAGE,alog10(im),pos=pos,stretch=1, /noerase,/Keep_aspect_ratio, $
	  minvalue=minvalue, maxvalue=maxvalue
  endif else begin
	nan_ind = where(im eq 0.0, nan_ct)
	if nan_ct gt 0.0 then $
		im[nan_ind] = !values.f_nan
    minvalue=min(im,/nan)
    maxvalue=max(im,/nan)
    if minvalue eq maxvalue then begin
	  minvalue=-1 & maxvlaue=1
    endif
	minvalue = minvalue-(maxvalue - minvalue)/nlevels
    CGIMAGE,im,pos=pos,stretch=1, /noerase,/Keep_aspect_ratio, $
	  minvalue=minvalue, maxvalue=maxvalue, background ='white', $
	  bottom = 0.1
  endelse
  cgloadct,0,/SILENT

  ; LABLE OF FIGURE
  label={title:'!8I!X!DCO!N '} ; edited by Eric, integrated intensity
  if tag_exist(label,'xtitle') then xtitle=label.xtitle
  if tag_exist(label,'ytitle') then ytitle=label.ytitle
  if tag_exist(label,'xmid') then xmid=label.xmid
  if tag_exist(label,'ymid') then ymid=label.ymid
  ytickformat=''      ;ytickformat='(A1)'
  ;print,'label',label
  ;help, label
  
  ; galaxy center
  extast, imhd, imastr
  ihr = float((strsplit(ra_c,'h',/extract))[0])
  imin = float((strsplit((strsplit(ra_c,'h',/extract))[1], 'm', /extract))[0])
  xsec = float((strsplit((strsplit(ra_c,'m',/extract))[1], 's', /extract))[0])
  ideg = float((strsplit(dec_c,'d',/extract))[0])
  imn = float((strsplit((strsplit(dec_c,'d',/extract))[1], 'm', /extract))[0])
  xsc = float((strsplit((strsplit(dec_c,'m',/extract))[1], 's', /extract))[0])
  ra_c = ihr * (360./24.) + imin * (360./(24.*60.)) + $
      xsec * (360./(24. * 60. * 60))     ; in [degree]
  dec_c = abs(ideg) + imn * (1./60.) + xsc * (1./3600.)   ; in [degree]
  dec_c = dec_c * ideg/abs(ideg)

  ad2xy, ra_c, dec_c, imastr, gal_xc, gal_yc
  ;print,'==========================================='
  print,'Center of Galaxy in Pixel:', gal_xc, gal_yc
  ;print,'==========================================='


  ; IMAGE CONTOUR
  imcontour_ljliu,im,imhd,$
      /noe,/nodata,pos=pos,type=0,$
      title=dataid,xtitle='', $
	  ytitle='', $
      /overlay,$
      ytickformat=ytickformat,$
      subtitle=' ',xmid=gal_xc,ymid=gal_yc,$
	  ;xdelta=xdelta, ydelta=ydelta,$
      color='black',AXISCOLOR='black', $
	  charsize=2.2, charthick=5.0, xthick=10, ythick=10


  ; ADD AXIS IN [PC]
  arctopc = !pi/(180.*3600.)*dist_pc
  CDELT1=SXPAR(imhd, 'CDELT1')
  CDELT2=SXPAR(imhd, 'CDELT2')
  xcrange = (!x.crange+0.5+1 - gal_xc)*cdelt1*3600.
  ycrange = (!y.crange+0.5+1 - gal_yc)*cdelt2*3600.
  cgAxis, /xAxis, xrange=[xcrange[0]*arctopc,xcrange[1]*arctopc], $
     xtitle=' ', font=1.95, charsize=2.2, xthick=10, charthick=5,xst=1,yst=1
  cgAxis, /yAxis, yrange=[ycrange[0]*arctopc,ycrange[1]*arctopc], $
     ytitle=' ', font=1.95, charsize=2.2, ythick=10, charthick=5,xst=1,yst=1


  ; XTITLE AND YTITLEDD AXIS IN [PC]
  ; cgtext, 0.52, 0.02, '$\Delta$$\alpha$ (arcsec)', alignment=0.5,$
  ;     charsize = 2.0, charthick=5.0, orientation = 0,/normal
  ; cgtext, 0.03, 0.52, '$\Delta$$\delta$ (arcsec)', alignment=0.5, $
  ;     charsize = 2.0, charthick=5.0, orientation = 90,/normal
  ; cgtext, 0.52, 0.96, '$\Delta$$\alpha$ (pc)', alignment=0.5,$
  ;     charsize = 2.0, charthick=4.0, orientation = 0,/normal
  ; cgtext, 0.96, 0.50, '$\Delta$$\delta$ (pc)', alignment=0.5, $
  ;     charsize = 2.0, charthick=4.0, orientation = -90,/normal

  ; changed by Eric
  cgtext, 0.52, 0.02, "RA - RA!Dcentre!N (arcsec)", alignment=0.5,$
      charsize = 2.2, charthick=5.0, orientation = 0,/normal
  cgtext, 0.06, 0.52, 'Dec. - Dec.!Dcentre!N (arcsec)', alignment=0.5, $
      charsize = 2.2, charthick=5.0, orientation = 90,/normal
  cgtext, 0.52, 0.96, 'RA - RA!Dcentre!N (pc)', alignment=0.5,$
      charsize = 2.2, charthick=5.0, orientation = 0,/normal
  cgtext, 0.96, 0.50, 'Dec. - Dec.!Dcentre!N (pc)', alignment=0.5, $
      charsize = 2.2, charthick=5.0, orientation = -90,/normal

  ; COLOR BAR
  cgloadct,3,/SILENT,/reverse, clip=[30,floor(255*nlevels/(nlevels+1))]
  if strtrim(sxpar(imhd,'BUNIT')) eq 'K km/s' or $
      strtrim(sxpar(imhd,'BUNIT')) eq 'K KM/S' then $
        title=label.title+'('+'K km s!U-1!N'+')'
  if keyword_set(log) then begin
    crange=[min(alog10(im),/nan),max(alog10(im),/nan)]
    if crange[0] eq crange[1] or (where(alog10(im) eq alog10(im)))[0] $
		eq -1 then crange=[-1.,1.]
	title='log('+label.title+'/K km s!U-1!N)'
  endif else begin
    crange=[min(im,/nan),max(im,/nan)]
    if crange[0] eq crange[1] or (where(im eq im))[0] eq -1 then crange=[-1.,1.]
  endelse

  if n_elements(barpos) eq 0 then barpos=[0.13, 0.87, 0.51, 0.90]

  ntick = 7
  tickint=fix(crange[1]-crange[0])/ntick
  tickint=round(tickint/5.)*5
  
  if n_elements(Tclip) eq 0 then begin
	cgCOLORBAR, range=crange, title=title, position=barpos, $
	  tlocation='bottom',tickinterval=tickint, charsize=1.7, textthick=3.0,/normal
  endif else begin
    tickvalue = tickint*(findgen(ntick)+1)
    ticknames = make_array(ntick,/string)
    for i = 0, n_elements(tickvalue) -1 do begin
        if tickvalue[i] le Tclip then begin
          ticknames[i] = strtrim(floor(tickvalue[i]),2)
        endif else begin
          tvalue = Tclip * (tan(tickvalue[i]/Tclip-1.)+1.)
          ticknames[i] = strtrim(floor(tvalue),2)
        endelse
    endfor

	cgCOLORBAR, range=crange, title=title, position=barpos, $
	tlocation='bottom',tickinterval=tickint, charsize=1.2, textthick=3.0, $
    /normal, ticknames=ticknames
  endelse


  cgloadct,0,/SILENT

  ; 'N' & 'E' direction
  getrot,imhd,rotang,cdelt
  imsz=size(im,/d)
  rotang_s=rotang+45.0
  ds=30./2.0/512*min(imsz)*sqrt(2)
  nexc=imsz[0]*0.92
  neyc=imsz[1]*0.08
  one_arrow,nexc+ds*sin(rotang_s/180*!dpi),neyc-ds*cos(rotang_s/180*!dpi),$
  +90+rotang,'N',color='black',/data,charsize=1.0, thick=5.
  one_arrow,nexc+ds*sin(rotang_s/180*!dpi),neyc-ds*cos(rotang_s/180*!dpi),$
  +180+rotang,'E',color='black',/data,charsize=1.0, thick=5.

  ; PLOT BEAM SHAPE
  RADIOHEAD,imhd,s=s
  psize=abs(s.cdelt[0])*3600   ; arcsec per pixel
  sz=size(im,/d)

  tvellipse,s.bmaj/2.0/psize,s.bmin/2.0/psize,$
    sz[0]/20.0,sz[1]/10.0,$
    s.bpa-90.0+rotang,$
    /data,noclip=0,color=cgcolor('black'),/fill, thick=3.0

  ; LABLE EACH GMC
  restore, inprop
  ; restore, inpmom
  numbers=(size(props))[1]
  ;resolves=props.resolved_extrap
  ; We consider a cloud resolved when its deconvolved diameter is at 
  ; least one beam wide (its radius is greater than or equal to half 
  ; of the beam size) and its deconvolved velocity width is at least 
  ; as wide as half of one (Hanning smoothed) velocity channel
  galaxy=(strsplit(infile,'/',/extract))[-1]
  if (strmatch(galaxy,'*_*',/fold_case) eq 1) then begin
    galaxy=(strsplit(galaxy,'_',/extract))[0]
  endif
  if (strmatch(galaxy,'*.*',/fold_case) eq 1) then begin
    galaxy=(strsplit(galaxy,'.',/extract))[0]
  endif
  print, 'Galaxy Name: ', galaxy

  degperpix = sqrt(abs(sxpar(hdr, "cdelt1"))*abs(sxpar(hdr, "cdelt1")))
  bmaj_deg = sxpar(hdr, "BMAJ")
  bmin_deg = sxpar(hdr, "BMIN")
  beamfwhm_deg = sqrt(bmaj_deg*bmin_deg)
  beamfwhm_pc = beamfwhm_deg * !dtor * dist_pc    ; in pc
  beamfwhm_pix = beamfwhm_deg/degperpix
  pixperbeam = (beamfwhm_pix/2.0)^2*!pi/alog(2.)
  dv =  abs(sxpar(hdr, 'CDELT3'))  ; in 'km/s'
  dv2 = dv
  ; if galaxy eq 'NGC4429' then begin
  ;     beamfwhm_pc = 14. * sqrt(alog(2.))
  ;     dv = 2.
	 ;  dv2 = 0.0
  ; endif

  ; resolves = (props.radrms_extrap_deconv ge beamfwhm_pc/2./sqrt(alog(2.)) $
  ;   and (props.vrms_extrap_deconv ge dv/2.) $
  ;   and (props.vrms_gauss_extrap_deconv ge dv2/2.) and $
  ;   (props.area ge pixperbeam))

  resolves = (props.radrms_extrap_deconv ge beamfwhm_pc/2.)  $ ; new criteria by Eric, beamfwhm_pc
    and (props.vrms_extrap_deconv ge dv/2.)

  pcperpix = (props.pcperpix)[0]
  ; ell_to_sig_half = 1.69536  ; corrsponding to the 60% confidence level

  ; changed order and color by Eric

  ;  (2) Label unresolved GMCs
  unres_inds=where(resolves eq 0, unres_ct)
  print, 'Unresolved Clouds: '+string(unres_ct,format='(I)')+' GMCs'

  unres_ct_cleaned = 0

  if unres_ct gt 0 then begin
    for i=0, unres_ct-1 do begin
      this_prop=props[unres_inds[i]]

      this_unresolved = array_unre[unres_inds[i]]

      if this_unresolved gt 0.5 then begin

        unres_ct_cleaned = unres_ct_cleaned+1

        ; this_mom=moments[unres_inds[i]]
        ; print, unres_inds[i], size(this_prop.majrms_extrap_deconv) ; this_prop.majrms
        major=this_prop.majrms/pcperpix*this_prop.rmstorad  ;*ell_to_sig_half    ;in [pixel] ; changed by Eric
        minor=this_prop.minrms/pcperpix*this_prop.rmstorad  ;*ell_to_sig_half    ;in [pixel] ; changed by Eric
        xpos=(this_prop.mom1x)-(xmin-xpad1)
        ypos=(this_prop.mom1y)-(ymin-ypad1)
        posang=this_prop.momposang
        posang=posang*!radeg
        ; print, this_prop.peaknum, major, minor, sqrt(major*minor), beamfwhm_pc/pcperpix
       

       check = where( this_prop.peaknum eq particular, count)
       
       if  (n_elements(particular) eq 0) or (count gt 0) then begin ; Eric added, either plot the whole catalog or plot a single cloud
        tvellipse, major, minor, xpos, ypos, posang, $
          /data, noclip=0, color=cgcolor('GRN5'), thick=3.0

        id = this_prop.peaknum

        if keyword_set(plcloudNr) then $
          xyouts, xpos,ypos, strtrim(id,2), alignment=0.5, charsize=0.25
        
        endif ; end particular check

    endif ; end further criterium check

    endfor ; end for unres_ct
  endif ; end unres_ct

  print, 'Unresolved Clouds after checking: '+string(unres_ct_cleaned,format='(I)')+' GMCs'


  ;  (1) Label resolved GMCs
  res_inds=where(resolves eq 1, resolve_ct)
  print, 'Resolved Clouds: '+string(resolve_ct,format='(I)')+' GMCs'

  
  res_ct_cleaned = 0

  if resolve_ct gt 0 then begin
    for i=0, resolve_ct-1 do begin
      this_prop=props[res_inds[i]]
      ; this_mom=moments[res_inds[i]]

      this_resolved = array_re[res_inds[i]]

      if this_resolved gt 0.5 then begin

        res_ct_cleaned = res_ct_cleaned+1

        major=this_prop.majrms/pcperpix*this_prop.rmstorad  ;*ell_to_sig_half    ;in [pixel] ; changed by Eric
        minor=this_prop.minrms/pcperpix*this_prop.rmstorad  ;*ell_to_sig_half    ;in [pixel] ; changed by Eric
        xpos=(this_prop.mom1x)-(xmin-xpad1)
        ypos=(this_prop.mom1y)-(ymin-ypad1)
    	  posang=this_prop.momposang
        posang=posang*!radeg
        ; print, this_prop.peaknum, major, minor, sqrt(major*minor), beamfwhm_pc/pcperpix
        
       check = where( this_prop.peaknum eq particular, count)
       if  (n_elements(particular) eq 0) or (count gt 0) then begin ; added by Eric

        tvellipse, major, minor, xpos, ypos, posang, $
          /data, noclip=0, color=cgcolor('blue'), thick=3.0

       id = this_prop.peaknum
       if keyword_set(plcloudNr) then $
          xyouts, xpos,ypos, strtrim(id,2), alignment=0.5, charsize=0.25

        endif
	
    endif ; end further criterium check
	 
   ; print cloud Nr
	
    endfor     ; end for i=0, resolve_ct-1

  endif	  ; end resolve_ct

  print, 'Resolved Clouds after checking: '+string(res_ct_cleaned,format='(I)')+' GMCs'

  ;  Labels
  if n_elements(labelpos) eq 0 then labelpos=[0.08, 0.90, 0.08, 0.86]
  ;  (1). resolved and unresolved clouds
  tvellipse, 0.012, 0.006, 0.63, 0.88, 0.0, $ ; was 0.012, 0.006, 0.54, 0.88, 0.0
        noclip=0, color=cgcolor('blue'), thick=3.0, /normal
  xyouts, 0.65, 0.875, $ ; was 0.56, 0.87, Eric
      strtrim(res_ct_cleaned,2)+' resolved GMCs', color=cgcolor('blue'), $ ; used to be resolve_ct
	  charsize=1.7, charthick = 4.0, /normal

  tvellipse, 0.012, 0.006, 0.63, 0.85, 0.0, $ ; was 0.012, 0.006, 0.54, 0.85, 0.0
        noclip=0, color=cgcolor('GRN5'), thick=3.0, /normal
  xyouts, 0.65, 0.845, $ ; was 0.56, 0.84 Eric
      strtrim(unres_ct_cleaned,2)+' unresolved GMCs', color=cgcolor('GRN5'), $ ; used to be unres_ct
	  charsize=1.7, charthick = 4.0, /normal
  

  ;  (2). 100 pc or 500 pc line
  if (n_elements(scale_label) eq 0) then scale_label = '100 pc'

  if (scale_label eq '100pc') or (scale_label eq '100 pc') or $
	  (scale_label eq '100_pc') or (scale_label eq '100-pc') then begin 
        scale_label = '100 pc'
		scale_pixels = 100./pcperpix
  endif


  if (scale_label eq '200pc') or (scale_label eq '200 pc') or $
	  (scale_label eq '200_pc') or (scale_label eq '200-pc') then begin 
        scale_label = '200 pc'
		scale_pixels = 200./pcperpix
  endif

  if (scale_label eq '20pc') or (scale_label eq '20 pc') or $
	  (scale_label eq '20_pc') or (scale_label eq '20-pc') then begin 
        scale_label = '20 pc'
		scale_pixels = 20./pcperpix
  endif

  if (scale_label eq '500pc') or (scale_label eq '500 pc') or $
	  (scale_label eq '500_pc') or (scale_label eq '500-pc') then begin 
        scale_label = '500 pc'
		scale_pixels = 500./pcperpix
  endif

  ;print,'scale_pixels',scale_pixels
  ;print,'pcperpix',pcperpix
  xline = findgen(1e4)/1e4*scale_pixels+imsz[0]/10.
  yline = make_array(1e4) + imsz[1]/10.
  oplot, xline, yline, linestyle=0, thick=5, color=cgcolor('black')
  xyouts, mean(xline), yline[0] - imsz[1]/30, scale_label, charsize=1.2, $
			color=cgcolor('black'), charthick=4., alignment = 0.5

  ;  (3) plot different radii regions 
  if n_elements(plellradius) gt 0 then begin
    ; 3.1 ) galaxy center pixel - xc, yc
    xc = gal_xc
    yc = gal_yc

    ; 3.2) pcperpix and axis ratio
    extast, hdr, astr
    xy2ad, [0,1], [0,0], astr, ra, dec
    degperpix = sphdist(ra[0], dec[0], ra[1], dec[1], /deg)
    pcperpix= degperpix*!dtor*(props[0].dist_pc)
    axis_ratio = cos(inc/90.*!pi/2.)  ; major and minor axis ratio of gas disk

    ; 3.3) major axis
    for i = 0, n_elements(plellradius)-1 do begin
      ellmaj = plellradius[i]      ; in pc
      ellmaj = ellmaj / pcperpix   ; in pixel
      ellmin = ellmaj * axis_ratio

      tvellipse, ellmaj, ellmin, xc, yc, pa+90., $
        /data, noclip=0, color=cgcolor('brown'), thick=8.0, linestyle=2
    endfor


	
	
  endif


  device,/close
  set_plot,'X'

; Export to pdf
 ; cgPS2PDF, outfile


END
