Function plane_function, x,y,p

; Z - velocity
; x - xaxis
; y - yaxis
;   p[0] - c
;   p[1] - a
;   p[2] - b

   ;logN=alog10((10.^x/p[0])^(p[1]+1.))
   Z = p[0] + p[1]*x + p[2]*y
   return, Z
End


function WHERE_XYZ, Array_expression, Count, XIND=xind, YIND=yind, ZIND=zind
; works for 1, 2 or 3 dimensional arrays
;
; Returns the 1D indices (same as WHERE)
;
; ARGUMENTS
;  - same as WHERE (see WHERE)
;
; KEYWORDS
; - Optionally returns X, Y, Z locations through:
;
; XIND: Output keyword, array of locations
; along the first dimension
; YIND: Output keyword, array of locations
; along the second dimension (if present)
; ZIND: Output keyword, array of locations
; along the third dimension (if present)
;
; If no matches where found, then XIND returns -1
;
  index_array=where(Array_expression, Count)
  dims=size(Array_expression,/dim)
  xind=index_array mod dims[0]
   case n_elements(dims) of
     2: yind=index_array / dims[0]
     3: begin
          yind=index_array / dims[0] mod dims[1]
          zind=index_array / dims[0] / dims[1]
        end
     else:
   endcase
  return, index_array
  end

PRO cpropstoo_angmom_comparison, infile = infile $
					, inprop = inprop $
				    , inassign = inassign $
					, rotfits = rotfits $
	                , remove_boundary = remove_boundary $
	                , fast = fast $
					, outtable = outtable $
					, outfile = outfile $ 
          , fits_file = fits_file $
          , plot_only = plot_only $
                      ,checkfile_re = checkfile_re $
                        ,checkfile_unre = checkfile_unre

          ; , intable = intable $
          ; , inner_pc = inner_pc $
          ; , ring_pc = ring_pc $
          ; , outer_pc = outer_pc $


;+
; NAME: 
;   cpropstoo_angmom_comparison

; PURPOSE:
;   Compare the observed angular speed (omega) and rotation axis (theta) with
;   modelled angular speed (omega) and rotation axis (theta)
;  
; INPUTS:
; infile      --  corrected data fits
; inprop      --  the '.idl' file for output of cpropstoo-'moments_to_props'
; inassign    --  the fits file of the GMCs assignment cube
; rotfits     --  the los velocity of galaxy rotation generated by "makeVfield"
;
; KEYWORD:
; remove_boundary -- do not fit boundary pixels of clouds
; fast        --  use PLANEFIT instead of lts_planefit to speed up the 
;				  plane-fitting
;    
; OUTPUTS:
; outfile     --  the '.eps' file for output figure
; 
; HISTORY:
;   20170306  LJ   introduced
;   20211105  WR  Update the error calculation using mpfit2dfun (this replaces the planefit)

; HEAD MESSAGE
  print, '============================================================='
  print, 'CPROPSTOO: Compare observed omega/theta with modelled values'
  print, '============================================================='

; READ IN DATA AND SET RESOLVES IND
  restore, inprop

  ; distance = props.r_gal
  ; R = props.RADRMS_EXTRAP_DECONV

  ; resolve = props.resolve_spatial * props.resolve_spectral

array_re = fltarr(file_lines(checkfile_re))
openr, lun, checkfile_re, /get_lun
readf, lun, array_re
free_lun, lun

array_unre = fltarr(file_lines(checkfile_unre))
openr, lun, checkfile_unre, /get_lun
readf, lun, array_unre
free_lun, lun

  cloud_or = array_re + array_unre

  ; readcol,intable, ID, RA, Dec, Vlsr, R, d_R, vrms, d_vrms, vturb, d_vturb, $
  ;         Lum, d_Lum, Mlum, d_Mlum, Tmax, Omega_shear, Theta_shear,distance, $
  ;         F='I, a, a, f, f, f, f, f, f, f, f, f, f, f, f, f, f, f'

  ; res_ind = resolve * (R le 10000.0) * (R gt 30.0) * (distance le 250)

  ; ind = where(resolve eq 1.0, res_ct)
  ; n = n_elements(R) 
  ; print,'res_ct',res_ct
  ; print, 'n=', n

  ; distance = distance[res_ind]
  ID_array = props.peaknum
  ; ; print, ID_array

; for plotting
  ; inner_ind = where((distance le inner_pc) and resolve , inner_ct)
  ; ring_ind = where((distance gt ring_pc[0]) and (distance le ring_pc[1]) and resolve, ring_ct)
  ; outer_ind = where(distance gt outer_pc[0] and (distance le outer_pc[1]) and resolve, outer_ct)

; GALAXY NAME
  ; galaxy=(strsplit(infile,'/',/extract))[-1]
  ; if (strmatch(galaxy,'*_*',/fold_case) eq 1) then begin
  ;   galaxy=(strsplit(galaxy,'_',/extract))[0]
  ; endif
  ; if (strmatch(galaxy,'*.*',/fold_case) eq 1) then begin
  ;   galaxy=(strsplit(galaxy,'.',/extract))[0]
  ; endif
  ; print, 'Galaxy Name: ', galaxy


  if ~keyword_set(plot_only) then begin ; added by Eric
; MODELLED OMEGA AND THETA

  data=readfits(infile, hdr)
  assign=readfits(inassign, ahr)
  rotdat=readfits(rotfits, rhd)       ; in [km/s]

  vectorify, data, x = x, y = y, v = v, $
      t = t

  rotsz = size(rotdat)
  datsz = size(data)

  if array_equal(rotsz[1:3],datsz[1:3]) ne 1 then begin
	  print,'Error: size of rotdat is not same as size of data cube!'
	  exit
  endif


  ; smooth rotdat

  ; ppbeam = (props.pixperbeam)[0]
  ; beaminpix = sqrt(ppbeam/!pi*alog(2.))*2./2.354  ; sigma
  ; smfwhm = beaminpix*2.354*1.0
  ; print, smfwhm
  
    ; psf=psf_gaussian(npixel=[floor(smfwhm)*6.,floor(smfwhm)*6.], $
    ;   FWHM = smfwhm , /normal)

  bmaj = (props.bmaj_deg)[0]
  bmin = (props.bmin_deg)[0]
  bpa = (props.bpa_deg)[0]
  deg_per_pix = (props.degperpix)[0]
  bmaj = bmaj / deg_per_pix
  bmin = bmin / deg_per_pix

; edited by Eric
  psf=psf_gaussian(npixel=[floor(bmaj)*6.,floor(bmaj)*6.], $
      FWHM = [bmin, bmaj] , /normal)
  psf = ROT(psf, -1*bpa) 
  
  rotdat2d = rotdat[*,*,0]
  rotdat2d_sm = convol(rotdat2d, psf, /nan, /edge_mirror, /center, $
            missing=NaN, /normalize)
  for i = 0, rotsz[3]-1 do begin
     rotdat[*,*,i] = rotdat2d_sm
  endfor

  ;vaxis_old
  rdhd, hdr, s = hdstruct
  vaxis_old = hdstruct.v
  if strmatch(sxpar(hdr,'CUNIT3'),'*KM/S*') or $
      strmatch(sxpar(hdr,'CUNIT3'),'*km/s*') then begin
      vaxis_old = vaxis_old*1e3    ; in [km/s]
  endif


  chanelwidth = (props.chanwidth_kms)[0]  ; in [km/s]
  pcperpix = (props.pcperpix)[0]


  omega_o = make_array( n_elements(ID_array))
  theta_o = omega_o * 0.0
  omega_m = omega_o * 0.0
  theta_m = omega_o * 0.0
  chi2_arr = omega_o * 0.0
  err_omega_o = omega_o * 0.0
  err_theta_o = omega_o * 0.0
  err_omega_m = omega_o * 0.0
  err_theta_m = theta_o * 0.0
  a_out_array = theta_o * 0.0
  b_out_array = theta_o * 0.0
  a_out_array_model = theta_o * 0.0
  b_out_array_model = theta_o * 0.0

  n = n_elements(ID_array)

  for i=0, n-1 do begin
  ; for i=0, 109 do begin ; for testing purpose
  ; print, i
     ; id = res_ind[i]+1
     id = i + 1
	 this_prop = props[id-1]
     cloud_ind = where(assign eq id)

     if keyword_set(remove_boundary) then begin
      print, 'current cloud ID ', id
       mask = assign * 0
       mask[cloud_ind] = 1

       mask1 = shift(mask, 1,0,0)
       mask2 = shift(mask, -1,0,0)
       mask3 = shift(mask, 0,1,0)
       mask4 = shift(mask, 0,-1,0)
    
       mask_sum = mask1+ mask2 + mask3 + mask4  $
          + mask


      cloud_ind = where((mask_sum eq 5) and (assign eq id))

	   ; to make sure there are at least 10 pixels for plane-fitting
      ; if n_elements(where(mask_sum eq 5)) gt 10 then begin
      ;   ; print,'5'
    	 ;  cloud_ind = where((mask_sum eq 5) and (assign eq id))
      ; endif else begin
      ; if n_elements(where(mask_sum ge 4)) gt 10 then begin
      ;   ; print,'4'
  	   ;  cloud_ind = where((mask_sum ge 4) and (assign eq id))
      ; endif else begin
      ; if n_elements(where(mask_sum ge 3)) gt 10 then begin
      ;   print,'3'
      ;   cloud_ind = where((mask_sum ge 3) and (assign eq id))
      ; endif else begin
      ; if n_elements(where(mask_sum ge 2)) gt 10 then begin
      ;   print,'2'
  		  ; cloud_ind = where((mask_sum ge 2) and (assign eq id))
      ; endif else begin
      ; if n_elements(where(mask_sum ge 1)) gt 10 then begin
      ;   print,'1'
      ;   cloud_ind = where((mask_sum ge 1) and (assign eq id))
      ; endif else begin
      ;   print,"no boundary"
      ; endelse
      ; endelse
      ; endelse
      ; endelse
      ; endelse
      endif   ; end keyword 'remove_boundary'


     xcl = x[cloud_ind]
     ycl = y[cloud_ind]
     vcl = v[cloud_ind]
     tcl = t[cloud_ind]
     rvcl = rotdat[cloud_ind]

	 ; smoothed observed cloud mom1
     cldpad = 2
     cubify $
         , x = xcl, y = ycl, v = vcl, t = tcl $
         , cube = cldCube $
         , pad = cldpad $
         , location = cldLoc $
         , mask = cldMask

     ;   mask = finite(cldCube) * 1.0
     ;   ; mask[cloud_ind] = 1

     ;   mask1 = shift(mask, 1,0,0)
     ;   mask2 = shift(mask, -1,0,0)
     ;   mask3 = shift(mask, 0,1,0)
     ;   mask4 = shift(mask, 0,-1,0)
    
     ;   mask_sum = mask1+ mask2 + mask3 + mask4  $
     ;      + mask

     ;  cldCube[where((mask_sum lt 5))] = !values.f_nan

     ;    vectorify, cldCube, x = xcl, y = ycl, v = vcl, t = tcl


     ; cubify $
     ;     , x = xcl, y = ycl, v = vcl, t = tcl $
     ;     , cube = cldCube $
     ;     , pad = cldpad $
     ;     , location = cldLoc $
     ;     , mask = cldMask

     cldsz = size(cldCube)
     cldxaxis = (indgen(cldsz[1])+min(xcl)-cldpad)
     cldyaxis = (indgen(cldsz[2])+min(ycl)-cldpad)
     cldvaxis = (indgen(cldsz[3])+min(vcl)-cldpad)
     cldvaxis = cldvaxis*(vaxis_old[1]-vaxis_old[0])+vaxis_old[0]   ; in [km/s]
     cldxmap = (intarr(cldsz[2])+1) ## cldxaxis
     cldymap = cldyaxis ## (intarr(cldsz[1])+1)
     cldvcube = rebin(reform(cldvaxis,1,1,cldsz[3]), cldsz[1:3])

     cldmom0 = total(cldCube,3,/nan)
     cldmom1 = total(cldvcube*cldCube,3,/nan) / cldmom0    ; in [km/s] 

	   ; cldmom2 = cldmom1 * 0.0
     ; for m=0, cldsz[1]-1 do begin
     ;   for n=0, cldsz[2]-1 do begin
     ;     if total(cldCube[m,n,*], /nan) gt 0 then begin
     ;       cldmom2[m,n] = sqrt(total(cldCube[m,n,*]*((cldvcube[m,n,*] $
     ;           -cldmom1[m,n])^2), /nan)/(total(cldCube[m,n,*],/nan)))  ; in [km/s]
     ;     endif
     ;   endfor
     ; endfor

     ; psf=psf_gaussian(npixel=[cldsz[1],cldsz[2]], $
     ;     FWHM = smfwhm, /normal)
	 ; LIJIE LIU - It is important Not to convolv.
     ;cldmom0=convol(cldmom0, psf, /nan, /edge_mirror, /center, $
     ;          missing=NaN, /normalize)
     ;cldmom1=convol(cldmom1, psf, /nan, /edge_mirror, /center, $
     ;          missing=NaN, /normalize)

	 ; fit smooth observed cloud mom1
   ;   cl3d = array_indices(cldCube, cldLoc)
   ;   cldmom1vec=reform(cldmom1[cl3d[0,*],cl3d[1,*]])
	 ; cldmom2vec=reform(cldmom2[cl3d[0,*],cl3d[1,*]])

   ;   clderrcube = (cldvcube - rebin(cldmom1, cldsz[1:3]))^2
   ;   cldmom1err = this_prop.noise/cldmom0 * sqrt(total(clderrcube,3,/nan))
   ;   cldweights = 1.0/(cldmom1err^2)
   ;   wt = reform(cldweights[cl3d[0,*],cl3d[1,*]])

    ind_temp = WHERE_XYZ(finite(cldmom1), XIND=xind, YIND=yind) 
    mom1vec_new = cldmom1[ind_temp]
    int_wt = cldmom0[ind_temp]


     
	 if keyword_set(fast) then begin
       ;coef = PLANEFIT(xcl, ycl, cldmom1vec, wt, vfit) ; in [channel/pixel]
       ;coef = this_prop.planefit_coef   ; in [kms/pixel]
       ;coef = coef/chanelwidth   ; in [channel/pixel]
	   p0 = [1300,1.0,0]

     if total(finite(mom1vec_new)) ge 10 then begin
  	   ; coef = mpfit2dfun('plane_function',xcl,ycl,cldmom1vec,cldmom2vec,p0,weights=wt,perror=perror,quiet=1)
       ; coef = mpfit2dfun('plane_function',xind,yind,mom1vec_new, FLTARR((size(xind))[1])+1.0 ,p0, perror=perror,quiet=1) ; Eric v2, error=1.0 m/s, half channel width
       ; coef = mpfit2dfun('plane_function',xind,yind,mom1vec_new, FLTARR((size(xind))[1])+1.0 , p0, weights = wt, perror=perror,quiet=1) ; Eric v3, intensity weighting, but why weights = wt?
       coef = mpfit2dfun('plane_function',xind,yind,mom1vec_new, FLTARR((size(xind))[1])+1.0 ,  p0, weights = int_wt, perror=perror,quiet=1) ; Eric v4, fitting mom1 with mom0 weighting, error input is ignored when weight is present
  	   a = coef[1]
  	   b = coef[2]
  	   da = perror[1]
  	   db = perror[2]
       a_out_array[i] = a
       b_out_array[i] = b
    endif else begin
      if cloud_or[i] gt 0.5 then print, 'Too few pixels in moment 1 map'
       a = !values.f_nan
       b = !values.f_nan
       da = !values.f_nan
       db = !values.f_nan
    endelse

	 endif 
  ; else begin ; the slower fitting algorithm lts_planefit_ljliu, obsolete now
	;    snr = (this_prop.maxval)/(this_prop.noise)
	;    sigx = xcl * 0d + ppbeam/snr    ; sigx = beamsize/(S/N)
	;    sigy = ycl * 0d + ppbeam/snr    ; sigy = beamsize/(S/N)
	;    ;sigz = reform(cldmom1err[cl3d[0,*],cl3d[1,*]])  ; sigv = chanwidth
	;    sigz = cldmom2vec       ; in [km/s]

	;    lts_planefit_ljliu, xcl, ycl, cldmom1vec, sigx, sigy, sigz, $
	; 	 abc, sig_abc, chi2, PIVOTX=median(xcl), PIVOTY=median(ycl)

	;    chi2_arr[i] = chi2
	;    a = abc[1]
	;    b = abc[2]
	;    da = sig_abc[1]
	;    db = sig_abc[2]
	;  endelse

     omega_o[i] = sqrt(a^2.+b^2.)         ; in [kms/pixel]
     err_omega_o[i] = sqrt(a^2.*da^2.+b^2.*db^2.)/omega_o[i]

     omega_o[i] = omega_o[i]/pcperpix   ; in [kms/pc]
     err_omega_o[i] = err_omega_o[i]/pcperpix   ; in [kms/pc]
     ; print, ID_array[i], omega_o[i], err_omega_o[i]

    ; added by Eric
    if err_omega_o[i] gt (100*omega_o[i]) then begin 
      err_omega_o[i] = !values.f_nan
      omega_o[i] = !values.f_nan
    endif

	 ; angle of rotation axis relative to North direction, turning positive
	 ; into the direction of the RA
     theta_o[i] = (atan(a,-b) * !radeg + 270) mod 360 
	 ang_1 = (atan(a+da, -b+db) * !radeg + 270) mod 360
	 ang_2 = (atan(a+da, -b-db) * !radeg + 270) mod 360
	 ang_3 = (atan(a-da, -b+db) * !radeg + 270) mod 360
	 ang_4 = (atan(a-da, -b-db) * !radeg + 270) mod 360
	 ang_arr = [ang_1, ang_2, ang_3, ang_4]
	 err_theta_o[i] = abs(max(ang_arr) - min(ang_arr))/2.



	 ; smooth cloud rotation model mom1
     cubify $
         , x = xcl, y = ycl, v = vcl, t = rvcl $
         , cube = rvcube $
         , pad = cldpad $
         , location = cldLoc $
         , mask = cldMask

	 rotcldCube = cldCube 
	 ;rotcldCube = cldCube * 0.0 + 1.
     rotmom0 = total(rotcldCube,3,/nan)
     rotmom1 = total(rvcube*rotcldCube,3,/nan) / rotmom0

     ; sz_temp = size(rvcube)
     ; print, 'here'
     ; print, sz_temp
     ; print, floor(sz_temp[1]/2), floor(sz_temp[2]/2)
     ; print, rvcube[ floor(sz_temp[1]/2),floor(sz_temp[2]/2), *]

     ; psf=psf_gaussian(npixel=[cldsz[1],cldsz[2]], $
     ;     FWHM = smfwhm, /normal)
	 ; LIJIE LIU - It is important Not to convolv.
     ;rotmom0=convol(rotmom0, psf, /nan, /edge_mirror, /center, $
     ;          missing=NaN, /normalize)
     ;rotmom1=convol(rotmom1, psf, /nan, /edge_mirror, /center, $
     ;          missing=NaN, /normalize)

   ;   cl3d = array_indices(rvcube, cldLoc)
   ;   rotmom1vec=reform(rotmom1[cl3d[0,*],cl3d[1,*]])

	 ; ; rotwt - method 1
   ;   roterrcube = (cldvcube - rebin(rotmom1, cldsz[1:3]))^2
	 ; this_prop = props[i] ;res_ind
   ;   rotmom1err = this_prop.noise/rotmom0 * sqrt(total(roterrcube,3,/nan))
   ;   rotweights = 1.0/(rotmom1err^2)
   ;   rotwt = reform(rotweights[cl3d[0,*],cl3d[1,*]])
	 ; ; rotwt - method 2
   ;   ;rotwt = rotwt * 0.0 + 1.

    ind_temp = WHERE_XYZ(finite(rotmom1), XIND=xind_mock, YIND=yind_mock) 
    mom1vec_new_mock = rotmom1[ind_temp]
    int_wt_mock = rotmom0[ind_temp]

	 if keyword_set(fast) then begin
       ;rotcoef = PLANEFIT(xcl, ycl, rotmom1vec, rotwt, vfit)
	   p0 = [1300,1.,0.]
     if total(finite(mom1vec_new_mock)) ge 10 then begin
  	   ; rotcoef = mpfit2dfun('plane_function',xcl,ycl,rotmom1vec,sigz,p0,weights=rotwt,perror=perror,quiet=1)
       ; rotcoef = mpfit2dfun('plane_function',xind_mock,yind_mock,mom1vec_new_mock, FLTARR((size(xind_mock))[1])+1.0 ,p0,perror=perror,quiet=1) ; Eric v2, error=1.0 m/s, half channel width
       ; rotcoef = mpfit2dfun('plane_function',xind_mock,yind_mock,mom1vec_new_mock, FLTARR((size(xind_mock))[1])+1.0, weights=rotwt ,p0,perror=perror,quiet=1) ; Eric v3, intensity weighting
       rotcoef = mpfit2dfun('plane_function',xind_mock,yind_mock,mom1vec_new_mock, FLTARR((size(xind_mock))[1])+1.0 ,  p0, weights = int_wt_mock, perror=perror,quiet=1) ; Eric v4, mom1 fitting with mom0 weighting
  	   a = rotcoef[1]
  	   b = rotcoef[2]
  	   da = perror[1]
  	   db = perror[2]
       a_out_array_model[i] = a
       b_out_array_model[i] = b

    endif else begin
      if cloud_or[i] gt 0.5 then print, 'Too few pixels in moment 1 map'
           coef = fltarr(3) * !values.f_nan
           resid = !values.f_nan
           perror = !values.f_nan
    endelse

	 endif 
  ; else begin
	;    sigz = sigz     ; in [km/s]
	;    lts_planefit_ljliu, xcl, ycl, rotmom1vec, sigx, sigy, sigz, $
	;      rot_abc, sig_rot_abc, rot_chi2, PIVOTX=median(xcl), PIVOTY=median(ycl)
	;    a = rot_abc[1]
	;    b = rot_abc[2]
	;    da = sig_rot_abc[1]
	;    db = sig_rot_abc[2]
	;  endelse

     omega_m[i] = sqrt(a^2+b^2)  ; in [kms/pixel]
	   err_omega_m[i] = sqrt(a^2.*da^2.+b^2.*db^2.)/omega_m[i]  ; in [kms/pixel]

     omega_m[i] = omega_m[i]/pcperpix                ; in [kms/pc]
     err_omega_m[i] = err_omega_m[i]/pcperpix        ; in [kms/pc]

     ; added by Eric
     if err_omega_m[i] gt (100*omega_m[i]) then begin
      err_omega_m[i] = !values.f_nan
      omega_m[i] = !values.f_nan
    endif

	 ; angle of rotation axis relative to North direction, turning positive
	 ; into the direction of the RA
     theta_m[i] = (atan(a,-b) * !radeg + 270) mod 360 ; direction of rotation axis
	 ;if theta_m[i] gt 180 then theta_m[i] = theta_m[i] - 360
	 ang_1 = (atan(a+da, -b+db) * !radeg + 270) mod 360
	 ang_2 = (atan(a+da, -b-db) * !radeg + 270) mod 360
	 ang_3 = (atan(a-da, -b+db) * !radeg + 270) mod 360
	 ang_4 = (atan(a-da, -b-db) * !radeg + 270) mod 360
	 ang_arr = [ang_1, ang_2, ang_3, ang_4]
	 err_theta_m[i] = abs(max(ang_arr) - min(ang_arr))/2.

  endfor
  endif  ; added by Eric

  ; added by Eric
  ; if keyword_set(plot_only) then begin
  ; readcol, outtable, ID_array, omega_o, err_omega_o, omega_m, err_omega_m, theta_o, err_theta_o, theta_m, err_theta_m, a_input, b_input, $
  ;           F='I, f, f, f, f, f, f, f, f, f, f'
  ; ; print, 'N=', n_elements(omega_o) 
  ; ; ID_array = ID_array[res_ind]
  ; ; omega_o = omega_o[res_ind]
  ; ; err_omega_o = err_omega_o[res_ind]
  ; ; omega_m = omega_m[res_ind]
  ; ; err_omega_m = err_omega_m[res_ind]
  ; ; theta_o = theta_o[res_ind]
  ; ; err_theta_o = err_theta_o[res_ind]
  ; ; theta_m = theta_m[res_ind]
  ; ; err_theta_m = err_theta_m[res_ind]
  ; ; print, ID_array
  ; ; print, omega_o
  ; endif

  ; sign = (theta_m/theta_o)/abs(theta_m/theta_o)
  theta_m = theta_m
  theta_m[where(theta_m gt 180)] = theta_m[where(theta_m gt 180)] - 360
  theta_o = theta_o
  theta_o[where(theta_o gt 180)] = theta_o[where(theta_o gt 180)] - 360


  rotation = create_struct('ID', ID_array)
  rotation = create_struct(rotation, "omega_o", omega_o)
  rotation = create_struct(rotation, "err_omega_o", err_omega_o)
  rotation = create_struct(rotation, "theta_o", theta_o)
  rotation = create_struct(rotation, "err_theta_o", err_theta_o)
  rotation = create_struct(rotation, "omega_m", omega_m)
  rotation = create_struct(rotation, "err_omega_m", err_omega_m)
  rotation = create_struct(rotation, "theta_m", theta_m)
  rotation = create_struct(rotation, "err_theta_m", err_theta_m)

  mwrfits, rotation, fits_file, /create





; ; PLOT FIGURE

; !P.FONT = 1
;   set_plot, 'ps'
;   device, filename=outfile  $
;   , bits_per_pixel=8, /encapsulated, /inches, /color, xoffset=0., yoffset=0., xsize=10, ysize=5.0

;   ; !p.multi=[0, 2, 1]
;   !p.multi=[0, 2, 3, 0, 1]


; ; cgDisplay, 750, 500, Title='Filled Area Under a Curve'

;   ; -------------------------------------
;   ; Subplot - 1. plot omega_m vs omega_o
;   ; -------------------------------------
;   ; print,'******************************************'
;   ; print,'median(omega_m/omega_o)',median(omega_m/omega_o)
;   ; print,'median(omega_m[inner_ind]/omega_o[inner_ind])',median(omega_m[inner_ind]/omega_o[inner_ind])
;   ; print,'median(omega_m[ring_ind]/omega_o[ring_ind])',median(omega_m[ring_ind]/omega_o[ring_ind])
;   ; print,'median(omega_m[outer_ind]/omega_o[outer_ind])',median(omega_m[outer_ind]/omega_o[outer_ind])
;   ; if ~keyword_set(plot_only) then begin
;   ; print,'median(chi2_arr)',median(chi2_arr)
;   ; print,'n_elements(where(chi2_arr gt 1.))',n_elements(where(chi2_arr gt 1.))
;   ; endif
;   ; print,'******************************************'

;   xmin = 0.0
;   xmax = max(omega_m+err_omega_m/2., /nan)
;   ymax = max(omega_o+err_omega_o/2., /nan)
;   ; if galaxy eq 'NGC4429' then begin
; 	 ;  plotmax =1.5
;   ; endif else begin
; 	 ;  plotmax = (xmax > ymax) * 1.2
;   ; endelse

;   ; ploterror, omega_m, omega_o, err_omega_m/2., err_omega_o/2., psym=3, errthick=1, $
;   ;     xtitle='$\omega$!Dmodel!N (km s!U-1!N pc!U-1!N)', $
;   ;     ytitle='$\omega$!Dobs!N (km s!U-1!N pc!U-1!N)', $
;   ;     xrange=[0.0, 1.5], yrange=[0.0, 1.5], xst=1, yst=1, $ ;plotmax
;   ;     ;xrange=[0.0, 0.9], yrange=[0.0, 0.9], xst=1, yst=1, $
;   ;     charsize = 1.5, xthick=5, ythick=5, charthick=5, $
;   ;     pos = [0.09, 0.14, 0.49, 0.96]

;   ; ploterror, 1.2, 0.6, median(err_omega_m), median(err_omega_o), psym=3, errthick=1, $
;   ;     xtitle='$\omega$!Dmodel!N (km s!U-1!N pc!U-1!N)', $
;   ;     ytitle='$\omega$!Dobs!N (km s!U-1!N pc!U-1!N)', $
;   ;     xrange=[0.0, 1.5], yrange=[0.0, 0.6], xst=1, yst=1, $ ;plotmax
;   ;     ;xrange=[0.0, 0.9], yrange=[0.0, 0.9], xst=1, yst=1, $
;   ;     charsize = 1.5, xthick=5, ythick=5, charthick=5, $
;   ;     pos = [0.09, 0.14, 0.49, 0.96]


;   ; print, 'correlation coefficient of omega', CORRELATE(omega_m, omega_o)

;   if outer_ct gt 0 then begin
;     cgplot, omega_m[outer_ind], omega_o[outer_ind], psym=16, SYMSIZE=0.4,$
;     color=cgColor('red'), xrange=[0.0, 1.5], yrange=[0.0, 0.5]


;   ; plot solid line
;   xarr = findgen(1e4) - 5e3; /1e4*(plotmax-0.0) + 0.0
;   yarr = xarr
;   cgoplot, xarr, yarr, thick = 5, color='black'

; endif

;   if ring_ct gt 0 then begin
; 	  cgplot, omega_m[ring_ind], omega_o[ring_ind], psym=16, SYMSIZE=0.4,$
; 	    color=cgColor('dark green'),xrange=[0.0, 1.5], yrange=[0.0, 0.5]

;   ; plot solid line
;   xarr = findgen(1e4) - 5e3; /1e4*(plotmax-0.0) + 0.0
;   yarr = xarr
;   cgoplot, xarr, yarr, thick = 5, color='black'

; end

;   if inner_ct gt 0 then begin
;     cgplot, omega_m[inner_ind], omega_o[inner_ind], psym=16, SYMSIZE=0.4,$
;       ;xtitle='model $\Omega$ (km s!U-1!N pc!U-1!N)', $
;       ;ytitle='observed $\Omega$ (km s!U-1!N pc!U-1!N)', $
;       ;axiscolor='black', $
;       ;xrange=[xmin, xmax], yrange=[ymin, ymax], xst=1, yst=1, $
;       ;charsize = 1.5, xthick=5, ythick=5, charthick=5, $
;       ;pos = [0.09, 0.14, 0.49, 0.96], $
;       color=cgColor('blue'), xrange=[0.0, 1.5], yrange=[0.0, 0.5]
;   ;for i = 0, res_ct-1 do begin
;   ;xyouts, omega_m[i], omega_o[i], strtrim(res_ind[i]+1,2), $
;   ;	  alignment=0.5, color=cgcolor('red'), charsize=0.6
;   ;endfor

;   ; plot solid line
;   xarr = findgen(1e4) - 5e3; /1e4*(plotmax-0.0) + 0.0
;   yarr = xarr
;   cgoplot, xarr, yarr, thick = 5, color='black'

; end

;   ;   legend
;   title = []
;   color =[]
;   if inner_ct gt 0 then begin
;       title = [title, 'Inner GMCs']
;       color = [color, 'blue']
;   endif
;   if ring_ct gt 0 then begin
;       title = [title, 'Intermediate GMCs']
;       color = [color, 'dark_green']
;   endif
;   if outer_ct gt 0 then begin
;       title = [title, 'Outer GMCs']
;       color = [color, 'red']
;   endif
;   cglegend,title=[title], psym=16, $
;       symsize=1.2, color=[color], location=[0.12, 0.88], $
;       length=0.0, linestyle=2, thick=5.,$
;       VSpace=2.0, charsize=1.5, charthick=5.0


;   ;ind = where(omega_m/omega_o gt 2, ct)
;   ;for i = 0, ct-1 do begin
;   ;  xyouts, omega_m[ind[i]], omega_o[ind[i]], strtrim(ID_array[ind[i]], 2), $
;   ;           alignment=0.5, charsize=1.0, charthick = 5
;   ;endfor

;   ; -------------------------------------
;   ; Subplot - 2. plot theta_m vs theta_o
;   ; -------------------------------------

;   ; plot solid line
;   xarr = findgen(1000) - 500 ;/1e4*(plotmax-plotmin) + plotmin
;   yarr = xarr
;   cgplot, xarr, yarr, xrange=[-180, 180], yrange=[-180, 180], /NoData, pos = [0.59, 0.14, 0.99, 0.96],  $ ; , /NOERASE
;       axiscolor='black', $
;       xst=1, yst=1, $
;       charsize = 1.5, xthick=5, ythick=5,  $
;       xtitle='Model $\phi$!Drot!N (deg)',charthick=5

;   ; added by Eric
;   xpoly = [-180+2,-180+2,-180+90,180-2,180-2,180-90]
;   ypoly = [-180+90,-180+2,-180+2,180-90,180-2,180-2]
;   cgColorFill, xpoly, ypoly, color='gray'

;   ; plotmin = max([min([theta_m, theta_o])-20, 0.])
;   ; plotmax = min([max([theta_m, theta_o])+20, 360.])
;   ; ploterror, theta_m, theta_o, err_theta_m/2., $
; 	 ;  err_theta_o/2., psym=3, errthick=1, $
;   ;   xrange=[-180, 180], yrange=[-180, 180], _EXTRA={OVERPLOT:1};, _EXTRA={NOERASE:1} 
;   ; cgtext, 0.53, 0.40, 'Observed $\phi$!Drot!N (deg)', $
;   ;     charsize = 1.5, charthick=5.0, orientation = 90,/normal

;   ploterror, 150, -170, median(err_theta_m), $
;     median(err_theta_o), psym=3, errthick=1, $
;     xrange=[-180, 180], yrange=[-180, 180], _EXTRA={OVERPLOT:1};, _EXTRA={NOERASE:1} 
;   cgtext, 0.53, 0.40, 'Observed $\phi$!Drot!N (deg)', $
;       charsize = 1.5, charthick=5.0, orientation = 90,/normal

;   ; print, 'correlation coefficient of theta', CORRELATE(theta_m, theta_o)

;   if outer_ct gt 0 then $
;     cgoplot, (theta_m[outer_ind]), $
;         (theta_o[outer_ind]), psym=16, SYMSIZE=0.8,$
;         color=cgColor('red')

;   if ring_ct gt 0 then $
; 	  cgoplot, (theta_m[ring_ind]), $
; 	  	  (theta_o[ring_ind]), psym=16, SYMSIZE=0.8,$
; 	  	  color=cgColor('dark green')


;   if inner_ct gt 0 then $
;     cgoplot, (theta_m[inner_ind]), $
;         (theta_o[inner_ind]), psym=16, SYMSIZE=0.8,$
;         color=cgColor('blue')

;   ; legend
;   ;cglegend,title=[title], psym=16, $
;   ;    symsize=1.2, color=[color], location=[0.62, 0.88], $
;   ;    length=0.0, linestyle=2, thick=5.,$
;   ;    VSpace=2.0, charsize=1.5, charthick=5.0

;   ;added by Eric
;   ; yarr2 = xarr+90
;   ; yarr3 = xarr-90
;   ; cgoplot, xarr, yarr2, thick = 3, color='gray'
;   ; cgoplot, xarr, yarr3, thick = 3, color='gray'

;   cgoplot, xarr, yarr, thick = 5, color='black'

;   device, /close
;   set_plot,'X'




  ; print, omega_m, omega_o

; OUT TABLE
  if n_elements(outtable) gt 0 and (~keyword_set(plot_only)) then begin

    f_omega_o = make_array(n_elements(ID_array))
    f_theta_o = f_omega_o * 0.0
    f_omega_m = f_omega_o * 0.0
    f_theta_m = f_omega_o * 0.0
    f_err_omega_o = f_omega_o * 0.0
    f_err_theta_o = f_omega_o * 0.0
    f_err_omega_m = f_omega_o * 0.0
    f_err_theta_m = f_omega_o * 0.0

    f_omega_o = omega_o ; [res_ind]
    f_theta_o = theta_o
    f_omega_m = omega_m
    f_theta_m = theta_m
    f_err_omega_o = err_omega_o
    f_err_theta_o = err_theta_o
    f_err_omega_m = err_omega_m
    f_err_theta_m = err_theta_m

    openw, lun, outtable, /get_lun
    printf, lun, ';ID',',','peaknum',',','omega_o',',','d_Omega_o',',','omega_m',',', $
        'd_Omega_m',',','theta_o',',','d_theta_o',',','theta_m',',', $
        'd_theta_m',',','a_obs',',','b_obs',',','a_obs_m',',','b_obs_m', format='(A3,a1,A11,a1,A11,a1,A11,a1,A11,a1,A11,a1,A11,a1,A11,a1,A11,a1,A11,a1,A11,a1,A11,a1,A11,a1,A11)'

    real_ct = 1
    for i = 0, n_elements(ID_array)-1 do begin
      ; if f_omega_o[i] eq 0 then f_err_omega_o[i]=0
      ; if cloud_or[i] gt 0.5 then begin
        printf,lun,real_ct,',',ID_array[i],',',f_omega_o[i],',',f_err_omega_o[i],',', $
            f_omega_m[i],',',f_err_omega_m[i],',',f_theta_o[i],',', $
            f_err_theta_o[i],',',f_theta_m[i],',',f_err_theta_m[i], ',',a_out_array[i], ',',b_out_array[i], ',',a_out_array_model[i], ',',b_out_array_model[i], $
            format='(I4,a1,I4,a1,F11.5,a1,F11.5,a1,F11.5,a1,F11.5,a1,F11.3,a1,F11.3,a1,F11.3,a1,F11.3,a1,F11.3,a1,F11.3 ,a1,F11.3,a1,F11.3)' ; precision edited by Eric
        real_ct = real_ct + 1 
      ; endif
    endfor
    close, lun
    free_lun, lun

  endif

end
