PRO cpropstoo_gmc_vfield, intable = intable $
                                , inmask = inmask $
                                , inprop = inprop $
                                , ingalpar = ingalpar $
                                , rotfits = rotfits $
                                , impar = impar $
                                , impad = impad $
                                , nvel = nvel $
                                , dist_range = dist_range $
                                , boundary = boundary $
                                , plcloudNr = plcloudNr $
                                , outfile = outfile $
                      ,checkfile_re = checkfile_re 
; PURPOSE:
;   Plot the velocity field or angular momentum vectors of GMCs
;  
;   
; INPUTS:
;   infile       --  original data fits
;   inmask       --  the mask for galaxy/islands
;   inassign     --  the fits file of the GMCs assignment cube
;   inprop       --  the idl file of GMC's properties
;   impar        --  the image parameters, impar=[impad, athick, asize, arrowlen]
;                    impad     - pad of mom1 image
;                    athick    - the thickness of arrow
;                    asize     - the size of plot arrow in !D.X_SIZE
;                    arrowlen  - the length of plot arrow 
;   impad        --  the expand edges of image in X/Y directions [xdown, xup,
;                    yleft, yright] in pixel. EL: [ x1, x2, bottom, top]
;   rotfits      --  the los velocity of galaxy rotation generated by "makeVfield"
;   dist_range   --  range of dist to galactic center plotted in the map
;   nvel         --  then number of iso-velocity contour
;    
; OUTPUTS:
;   outfile        --  the '.eps' file for output figure

  readcol, intable, ID, ID_arr,omega_o,err_omega_o, $
            omega_m,err_omega_m,theta_o, $
            err_theta_o,theta_m,err_theta_m, a_array, b_array, a_array_m, b_array_m, $
            format='(I4,I4,F0.5,F0.5,F0.5,F0.5,F0.5,F0.5,F0.5,F0.5,F0.5,F0.5,F0.5,F0.5)',COMMENT=';'

; Eric: switch between observed clouds and mock clouds in plotting
; a_array = a_array_m
; b_array = b_array_m

array_re = fltarr(file_lines(checkfile_re))
openr, lun, checkfile_re, /get_lun
readf, lun, array_re
free_lun, lun

; ?
  ; ind = where(theta_o lt 90,ct)
  ; if ct gt 0 then theta_o[ind] = theta_o[ind]+360
  ; ind = where(theta_m lt 90,ct)
  ; if ct gt 0 then theta_m[ind] = theta_m[ind]+360

; DEFAULT INPUT
  if n_elements(nvel) eq 0 then nvel = 21
  if n_elements(impar) eq 0 then impar = [20, 3.0, 1/256., 15.] 
  ;impad = impar[0]
  athick = impar[1]
  asize = impar[2]
  arrowlen = impar[3]
  if n_elements(impad) eq 0 then impad = [30, 30, 30, 30]
  if n_elements(impad) eq 2 then impad = [impad[0], impad[0], impad[1], impad[1]]

  restore, inprop
  pcperpix = (props.PCPERPIX)[0]

  pa=0.0
  inc = 0.0
  ra_c = ''
  dec_c = ''
  dist_pc = 0.0
  blank = ''
  vsys = 0.0

  openr,lun,ingalpar,/get_lun
  readf,lun,blank
  readf,lun,blank
  readf,lun,blank
  readf,lun,blank
  readf,lun,pa
  readf,lun,blank
  readf,lun,inc
  readf,lun,blank
  readf,lun,blank
  readf,lun,blank
  readf,lun,ra_c
  readf,lun,blank
  readf,lun,dec_c
  readf,lun,blank
  readf,lun,dist_pc
  readf,lun,blank
  readf,lun,vsys

  close,lun
  free_lun,lun


; ROTMOM
  rotdat0 = readfits(rotfits)
  rotmom1 = rotdat0[*, *, 0]
  rotmom1 = rotmom1 - vsys


; IMAGE RANGE
  mask=readfits(inmask, hdr)
  mask2d = total(mask, 3, /nan)
  xmin = (where(total(mask2d, 2, /nan) gt 0))[0]
  xmax = (where(total(mask2d, 2, /nan) gt 0))[-1]
  ymin = (where(total(mask2d, 1, /nan) gt 0))[0]
  ymax = (where(total(mask2d, 1, /nan) gt 0))[-1]
  szim = size(mask)
  xpad1 = xmin < impad[0]
  xpad2 = impad[1] < (szim[1]-1-xmax)
  ypad1 = ymin < impad[2]
  ypad2 = impad[3] < (szim[2]-1-ymax)
  rotmom1 = rotmom1[xmin-xpad1:xmax+xpad2, ymin-ypad1:ymax+ypad2]

  extast, hdr, astr

  ihr = float((strsplit(ra_c,'h',/extract))[0])
  imin = float((strsplit((strsplit(ra_c,'h',/extract))[1], 'm', /extract))[0])
  xsec = float((strsplit((strsplit(ra_c,'m',/extract))[1], 's', /extract))[0])
  ideg = float((strsplit(dec_c,'d',/extract))[0])
  imn = float((strsplit((strsplit(dec_c,'d',/extract))[1], 'm', /extract))[0])
  xsc = float((strsplit((strsplit(dec_c,'m',/extract))[1], 's', /extract))[0])
  ra_c = ihr * (360./24.) + imin * (360./(24.*60.)) + $
      xsec * (360./(24. * 60. * 60))     ; in [degree]
  dec_c = abs(ideg) + imn * (1./60.) + xsc * (1./3600.)   ; in [degree]
  dec_c = dec_c * ideg/abs(ideg)

  ad2xy, ra_c, dec_c, astr, gal_xc, gal_yc



; clouds

  ; resolves = props.resolve_spatial and props.resolve_spectral

  res_ind=where(array_re gt 0.5, res_ct)

  d_theta_res = abs(theta_o[res_ind] - theta_m[res_ind])
  
  theind = where(d_theta_res gt 180., thect)
  if thect gt 0 then d_theta_res[theind] = 360.- d_theta_res[theind]

  prog_ind = where(d_theta_res lt 90.,test1)
  retro_ind = where(d_theta_res ge 90.,test2)

  print, 'Resolved clouds:', res_ct

  distance = (props.r_gal)[res_ind]
  ; print, size(distance)

  print, 'number of prograde clouds', n_elements(prog_ind)
  ; openw, lun, '/Users/liangf/work/output_publication/pro_ind.txt', /get_lun
  ; for i = 0, n_elements(prog_ind)-1 do begin
  ;     printf,lun,prog_ind[i],' ', distance[prog_ind[i]],format='(I4,A1,F0.2)'
  ; endfor
  ; close, lun
  ; free_lun, lun

  print, 'number of retrograde clouds', n_elements(retro_ind)
  ; openw, lun, '/Users/liangf/work/output_publication/retro_ind.txt', /get_lun
  ; for i = 0, n_elements(retro_ind)-1 do begin
  ;     printf,lun,retro_ind[i],' ', distance[retro_ind[i]],format='(I4,A1,F0.2)'
  ; endfor
  ; close, lun
  ; free_lun, lun

  x0 = make_array(res_ct, value=!values.f_nan)
  y0 = make_array(res_ct, value=!values.f_nan)
  x1 = make_array(res_ct, value=!values.f_nan)
  y1 = make_array(res_ct, value=!values.f_nan)
  cloudnr = make_array(res_ct, value=0, type=int)

  omega_o_temp = omega_o[res_ind]
  factor = omega_o[res_ind] / mean(omega_o_temp[where(finite(omega_o_temp))])

  for i=0, res_ct-1 do begin
      this_prop=props[res_ind[i]]
      cloudnum=this_prop.peaknum
      x0[i]=this_prop.mom1x
      y0[i]=this_prop.mom1y
      cloudnr[i] = floor(cloudnum)
       a = a_array[res_ind[i]]
       b = b_array[res_ind[i]]
      x1[i]=x0[i]-b*arrowlen/sqrt(a^2.+b^2.)
      y1[i]=y0[i]+a*arrowlen/sqrt(a^2.+b^2.)
    endfor

  ; x0, y0, x1, y1 
  x0=x0-(xmin-xpad1)
  y0=y0-(ymin-ypad1)
  x1=x1-(xmin-xpad1)
  y1=y1-(ymin-ypad1)
  gal_xc=gal_xc-(xmin-xpad1)
  gal_yc=gal_yc-(ymin-ypad1)

  ; added by Eric
  x0 = x0 - factor * (x1-x0)
  y0 = y0 - factor * (y1-y0)






; PLOT FIGURE
  !P.FONT = 1
  set_plot, 'ps'
  device, filename=outfile, bits_per_pixel=8, /encapsulated $
      , xsize=9.0, ysize=9.0, /inches, /color, xoffset=0., yoffset=0., SET_FONT='Times', /TT_FONT

  !p.thick = 1.5
  !x.thick = 1.5
  !y.thick = 1.5
  !z.thick = 1.5
  !p.charsize = 1.0
  !p.charthick = 1.5

  im=rotmom1

  ; calculate deprojected distance from each pixel to galaxy center
  imsz = size(im)
  imXaxis = indgen(imsz[1])
  imYaxis = indgen(imsz[2])
  imXmap = (intarr(imsz[2])+1) ## imXaxis
  imYmap = imYaxis ## (intarr(imsz[1])+1)
  im_dist = calc_distance(x1 = imXmap[0:n_elements(imXmap)-1], $
      y1 = imYmap[0:n_elements(imYmap)-1], x2 = gal_xc, y2=gal_yc, $
      in_pa = pa, in_inc=inc, pcperpix = pcperpix)
  rad_ind = where((im_dist ge dist_range[0]) and (im_dist le dist_range[1]), ct)
  if ct gt 0 then begin
      im1 = im
      im = im* !values.f_nan
      im[rad_ind] = im1[rad_ind]
  endif else begin
      print, 'WRONG DIST_RANGE!!!'
      return
  endelse


  ; axes
  imhd=hdr
  sz = size(im)
  CRPIX1=SXPAR(hdr, 'CRPIX1')
  CRPIX2=SXPAR(hdr, 'CRPIX2')
  sxaddpar, imhd, 'BUNIT', 'km/s', before='HISTORY'
  sxaddpar, imhd, 'NAXIS1', xmax-xmin+xpad1+xpad2+1, before='HISTORY'
  sxaddpar, imhd, 'CRPIX1', CRPIX1-(xmin-xpad1), before='HISTORY'
  sxaddpar, imhd, 'NAXIS2', ymax-ymin+ypad1+ypad2+1, before='HISTORY'
  sxaddpar, imhd, 'CRPIX2', CRPIX2-(ymin-ypad1), before='HISTORY'
  sxaddpar, imhd, 'NAXIS3', 1L, before='HISTORY'

  pos=[0.10,0.10,0.89,0.91]
  sauron_colormap
  imcontour_ljliu,im,imhd,$
      /noe,/nodata,pos=pos,type=0,$
      title=dataid,xtitle='', $
      ytitle='', $
      /overlay,$
      ytickformat=ytickformat,$
      subtitle=' ',xmid=gal_xc,ymid=gal_yc,$
      color='black',AXISCOLOR='black', $
      charsize=2.0, charthick=5.0, xthick=5, ythick=5

  ; add axis in [pc]
  arctopc = !pi/(180.*3600.)*dist_pc
  CDELT1=SXPAR(imhd, 'CDELT1')
  CDELT2=SXPAR(imhd, 'CDELT2')
  xcrange = (!x.crange+0.5+1 - gal_xc)*cdelt1*3600.
  ycrange = (!y.crange+0.5+1 - gal_yc)*cdelt2*3600.
  cgAxis, /xAxis, xrange=[xcrange[0]*arctopc,xcrange[1]*arctopc], $
     xtitle=' ', font=1.95, charsize=1.9, xthick=5, charthick=5,xst=1,yst=1
  cgAxis, /yAxis, yrange=[ycrange[0]*arctopc,ycrange[1]*arctopc], $
     ytitle=' ', font=1.95, charsize=1.9, ythick=5, charthick=5,xst=1,yst=1

  cgtext, 0.52, 0.02, "RA - RA!Dcentre!N (arcsec)", alignment=0.5,$
      charsize = 1.8, charthick=5.0, orientation = 0,/normal
  cgtext, 0.05, 0.52, 'Dec. - Dec.!Dcentre!N (arcsec)', alignment=0.5, $
      charsize = 1.8, charthick=5.0, orientation = 90,/normal
  cgtext, 0.52, 0.96, 'RA - RA!Dcentre!N (pc)', alignment=0.5,$
      charsize = 1.8, charthick=4.0, orientation = 0,/normal
  cgtext, 0.96, 0.50, 'Dec. - Dec.!Dcentre!N (pc)', alignment=0.5, $
      charsize = 1.8, charthick=4.0, orientation = -90,/normal


  ; plot isovelocity contours
  minvalue=min(im,/nan)
  maxvalue=max(im,/nan)
  d_vel=(maxvalue-minvalue)/(nvel-1.)

  sauron_colormap
  contour, im, levels=findgen(nvel)*d_vel+minvalue  $
         , c_colors=findgen(nvel)/(nvel-1.)*255. $
         , c_thick=8. ,/overplot


  tvellipse, boundary[0] / pcperpix, boundary[0] / pcperpix * cos(inc * !dtor),$
    gal_xc, gal_yc,$
    pa - 90, linestyle=0,$
    /data, noclip=0,color=cgcolor('gray'), thick=15.0

  tvellipse, boundary[1] / pcperpix, boundary[1] / pcperpix * cos(inc * !dtor),$
    gal_xc, gal_yc,$
    pa - 90,linestyle=0,$
    /data,noclip=0,color=cgcolor('gray'), thick=15.0


 ; color bar
  sauron_colormap
  crange=[minvalue, maxvalue]
  tickint=fix(crange[1]-crange[0])/7.
  tickint=round(tickint/10.)*10
  cgCOLORBAR, range=crange, POSITION=[0.13, 0.87, 0.53, 0.90] $
         , title='!8v!X!dmodel !n(km s!U-1!N)', tlocation='bottom' $
         ;, /discrete, ncolors=nvel, bottom=1, /addcmd $
         , tickinterval=tickint, charsize=1.5, textthick=3.0, /normal

  cgloadct, 0, /silent

; 'N' & 'E' direction
  getrot,imhd,rotang,cdelt
  imsz=size(im,/d)
  rotang_s=rotang+45.0
  ds=30./2.0/512*min(imsz)*sqrt(2)
  nexc=imsz[0]*0.92
  neyc=imsz[1]*0.08
  one_arrow,nexc+ds*sin(rotang_s/180*!dpi),neyc-ds*cos(rotang_s/180*!dpi),$
  +90+rotang,'N',color='black',/data,charsize=1.0, thick=5.
  one_arrow,nexc+ds*sin(rotang_s/180*!dpi),neyc-ds*cos(rotang_s/180*!dpi),$
  +180+rotang,'E',color='black',/data,charsize=1.0, thick=5.


  ; added by Eric
  size_pro = size(prog_ind,/n_elements)
  size_retro = size(retro_ind,/n_elements)
  indices_pro = Round( RandomU(seed, Round(size_pro/2)) * size_pro )
  indices_retro = Round( RandomU(seed, Round(size_retro/2)) * size_retro )

  x0_pro = x0[prog_ind]
  x0_retro=x0[retro_ind]
  x1_pro = x1[prog_ind]
  x1_retro=x1[retro_ind]
  y0_pro = y0[prog_ind]
  y0_retro = y0[retro_ind]
  y1_pro = y1[prog_ind]
  y1_retro = y1[retro_ind]
  
  cgarrow, x0_pro[indices_pro], y0_pro[indices_pro], x1_pro[indices_pro], y1_pro[indices_pro], $
    /data, /solid, thick=athick*2, hsize=!D.X_SIZE*asize*2, HTHICK=1.0*2, $
    color='black'
  cgarrow, x0_retro[indices_retro], y0_retro[indices_retro], x1_retro[indices_retro], y1_retro[indices_retro], $
    /data, /solid, thick=athick*2, hsize=!D.X_SIZE*asize*2, HTHICK=1.0*2, $
    color='dark gray'

  if keyword_set(plcloudNr) then begin
    for i = 0, n_elements(x0)-1 do begin
    xyouts, x0[i], y0[i], strtrim(cloudnr[i],2),alignment=0.5, charsize=0.5
    endfor
  endif


  device, /close
  set_plot,'X'

end